searchState.loadedDescShard("sage", 0, "The Sage Programming Language\nThe UNICODE character art for the logo of the language.\nThe UNICODE character art for the logo of the language, …\nThe value of the NULL pointer constant.\nAssembly Module\nLIR (Low Intermediate Representation) Module\nParsing Module\nSide Effects Module\nTargets Module\nVirtual Machine Module\nA frontend to both the <code>CoreProgram</code> and <code>StandardProgram</code> …\nAn error generated by assembling some assembly language …\nThe given global was not defined.\nThe given label was not defined.\nThe given instruction was not expected, or cannot be used …\nThe given instruction did not have a matching “end”. …\nIs this standard assembly operation supported by the …\nAn error generated by the virtual machine.\nInsert a comment into the program.\nCore Assembly Variant\nGet the current instruction number.\nReturns the argument unchanged.\nGet the operation at the given instruction number.\nAssembly Global Variables\nCalls <code>U::from(self)</code>.\nIs the given label defined yet in the operations? I.E., …\nAssembly Memory Location\nLog all the instructions after the given instruction …\nInsert a core operation into the program.\nStandard Assembly Variant\nAttempt to insert a standard operation into the program. …\nAdd an integer value from a source location to a …\nLogical “and” a destination with a source value.\nArithmetic right shift a destination by a source value. …\nStore a list of values at a source location. Then, store …\nGet a value in memory and call it as a label ID.\nCall a function with a given label.\nStore the comparison of “a” and “b” in a …\nWrite a set of values to a memory location.\nCopy a number of cells from a source referenced location …\nA core instruction of the assembly language. These are …\nAn assembly program composed of core instructions, which …\nDecrement the integer value of a location.\nDivide a destination location by a source value.\nDivide a destination location by a source value. Store the …\nAdd an “else” clause to an “if the value is not zero…\nTerminate a function declaration, a while loop, an if …\nDeclare a new label.\nGet a value from the input device / interface and store it …\nGet the address of a location, and store it in a …\nDeclare a global variable.\nBegin an “if the value is not zero” statement over a …\nIncrement the integer value of a location.\nGet the address of a location indexed by an offset stored …\nPerform dst = a == b.\nPerform dst = a &gt; b.\nPerform dst = a &gt;= b.\nPerform dst = a &lt; b.\nPerform dst = a &lt;= b.\nPerform dst = a != b.\nLeft shift a destination by a source value.\nLogical right shift a destination by a source value. This …\nMany instructions to execute; conveniently grouped …\nCopy a value from a source location to a destination …\nMultiply a destination location by a source value.\nNegate an integer.\nMake this pointer point to the next cell (or the nth next …\nReplace a value in memory with its boolean complement.\nLogical “or” a destination with a source value.\nPop a number of cells from the stack and store it in a …\nPop a number of cells from a specified stack and store it …\nMake this pointer point to the previous cell (or the nth …\nPush a number of cells starting at a memory location on …\nGet the address of a location and push it to the stack.\nPush a const to the stack.\nPush a number of cells starting at a memory location onto …\nPut a value from a source register to the output device / …\nStore the remainder of the destination modulus the source …\nReturn from the current function.\nSet the value of a register, or any location in memory, to …\nSet the value of a register, or any location in memory, to …\nSubtract a source integer value from a destination …\nSwap the values of two locations.\nPerform a SIMD addition over a vector of integers. This …\nPerform a vector “And” operation. This will perform a …\nPerform a SIMD arithmetic right shift operation over a …\nDecrement a vector of integers.\nPerform a SIMD division over a vector of integers. This …\nPerform a SIMD “is &gt;= zero” operation over a vector of …\nIncrement a vector of integers.\nPerform a SIMD pointer index operation over a vector of …\nPerform a SIMD left shift operation over a vector of …\nPerform a SIMD logical right shift operation over a vector …\nPerform a SIMD multiplication over a vector of integers. …\nNegate a vector of integers using SIMD.\nPerform a vector “Not” operation. This will replace …\nPerform a SIMD pointer arithmetic operation over a vector …\nPerform a vector “Or” operation. This will perform a …\nPerform a SIMD remainder over a vector of integers. This …\nSet the vector values of a destination.\nPerform a SIMD subtraction over a vector of integers. This …\nBegin a “while the value is not zero” loop over a …\nAssemble a program of core assembly instructions into the …\nThe list of core assembly instructions in the program.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new program of core assembly instructions.\nPush a string literal as UTF-8 to the stack.\nPut a string literal as UTF-8 to the output device.\nAllocate a string on the stack, and store its address in a …\nA lookup for all the global variables in an assembly …\nAdd a global variable to the list of globals.\nCreate a new empty <code>Globals</code> lookup.\nReturns the argument unchanged.\nGet the location, and size of a global variable.\nGet the location of a global variable.\nGet the size of a global variable. This is the number of …\nGet the size of the global variables. This is the number …\nCalls <code>U::from(self)</code>.\nCreate a new empty <code>Globals</code> lookup.\nResolve the global variables in a location to produce an …\nThe “A” general purpose register.\nA fixed position in the tape (a constant address known at …\nThe “B” general purpose register.\nThe “C” general purpose register.\nThe “D” general purpose register.\nThe “E” general purpose register.\nThe “F” general purpose register.\nThe frame pointer register.\nThe Global Pointer register. This is used to access global …\nA global variable.\nUse the value of a cell on the tape as an address. For …\nA location in memory (on the tape of the virtual machine).\nGo to a position in memory, and then move the pointer …\nThe stack pointer register.\nGet the location of the value pointed to by this location.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGet the location offset by a constant number of cells from …\nPerform inverse Cos on a cell (float) and store the result …\nPerform inverse Sin on a cell (float) and store the result …\nPerform inverse Tan on a cell (float) and store the result …\nAdd the source cell (float) to the destination cell …\nTake the value in the operand cell. Allocate that number …\nCall a foreign function.\nWrite some constant values to a location on the tape\nExecute a core instruction.\nPerform Cos on a cell (float) and store the result in the …\nDivide the destination cell (float) by the source cell …\nFree the memory allocated at the address stored in the …\nPerform dst = a &gt; b.\nPerform dst = a &lt; b.\nMultiply the source cell (float) by the destination cell …\nNegate the value of a cell (float) and store the result in …\nRaise a cell (float) to the power of another cell (float).\nPush some constant values to the stack.\nPerform the modulo operation on the destination cell …\nSet the value of a cell to a constant float.\nPerform Sin on a cell (float) and store the result in the …\nTake the square root of a cell (float).\nA standard instruction of the assembly language. These are …\nA program composed of standard instructions, which can be …\nSubtract the source cell (float) from the destination cell …\nPerform Tan on a cell (float) and store the result in the …\nTake the integer value stored in a cell and store the …\nTake the float value stored in a cell and store the …\nPerform a SIMD floating point inverse cosine operation.\nPerform a SIMD floating point inverse sine operation.\nPerform a SIMD floating point inverse tangent operation.\nPerform a SIMD floating point addition operation.\nPerform a SIMD floating point cosine operation.\nPerform a SIMD floating point division operation.\nPerform a SIMD floating point greater than or equal to …\nPerform a SIMD floating point multiplication operation.\nPerform a SIMD floating point negation operation.\nPerform a SIMD floating point power operation.\nPerform a SIMD floating point remainder operation.\nSet the vector values of a destination.\nPerform a SIMD floating point sine operation.\nPerform a SIMD floating point subtraction operation.\nPerform a SIMD floating point tangent operation.\nAssemble the program into a virtual machine program.\nThe list of standard assembly instructions in the program.\nGet the current instruction number.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the operation at the given instruction number.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the given label defined yet in the operations?\nCreate a new program of core assembly instructions.\nAdd a core operation to the program.\nAdd a standard operation to the program.\nThe first cell in the comparison (left hand side).\nThe first cell in the comparison (left hand side).\nThe second cell in the comparison (right hand side).\nThe second cell in the comparison (right hand side).\nThe beginning of the constant data.\nThe destination cell.\nThe destination cell.\nThe destination cell.\nThe destination cell.\nThe destination cell.\nThe destination cell.\nThe destination cell.\nThe destination cell.\nThe source cell.\nThe source cell.\nThe source cell.\nThe source cell.\nThe source cell.\nThe source cell.\nThe constant data.\nA boolean “And” operation between two values.\nAn error with some annotation about the source code that …\nAn expression along with data about its source code …\nAn annotation for metadata about an LIR expression. This …\nThe expression equal to any other expression.\nUnchecked access to a value. This is used to override …\nA type reserved by the compiler. This type is equal to any …\nApply a function with some arguments.\nA type that constructs a concrete type from a polymorphic …\nTried to apply a non-procedure to some arguments.\nTried to apply a non-template type to some arguments.\nAn arithmetic operation.\nAn array of constant values.\nAn array of expressions.\nAn array of a given type, with a constant size.\nCast a constant expression to another type.\nCast an expression to another type.\nAn error caused by trying to assemble invalid code …\nAn assignment operation. This is used to implement …\nA trait used to implemented an assignment operation.\nPerform an assignment operation on two expressions.\nA trait used to implement a binary operation.\nPerform a binary operation on two expressions.\nA boolean “BitwiseAnd” operation between two values.\nA boolean “BitwiseNand” operation between two values.\nA boolean “BitwiseNor” operation between two values.\nA boolean “BitwiseOr” operation between two values.\nA boolean “BitwiseXor” operation between two values.\nA constant boolean value.\nThe type of a boolean value.\nAn annotation for compiler-generated code.\nAn annotation for a constant.\nA constant integer value representing a cell on the tape.\nThe type of the most basic unit of memory.\nA constant chararacter.\nThe type of a character.\nA comparison operation between two values.\nA trait which allows an LIR expression to be compiled to …\nTried to  compile a polymorphic procedure without …\nIs this expression compiler-generated?\nA constant expression.\nA compiletime expression.\nA constant expression.\nA constant literal used in a type expression, like a …\nIs this expression a constant?\nA builtin pseudo-procedure implemented in the core …\nA builtin implemented in handwritten core assembly.\nRecursion depth exceeded when trying to confirm a type’s …\nAn annotation for dead code.\nGet the Union data associated with a tagged union …\nIs this expression dead code?\nA declaration of a variable, function, type, etc.\nBind a list of types in a constant expression.\nDeclare any number of variables, procedures, types, or …\nDereference this expression (i.e. get the value it points …\nStore an expression to an address (a pointer).\nTried to dereference a non-pointer.\nDuplicate implementations of a member for a type\nAn enumeration of a list of possible named values. A …\nA tagged union of constant values.\nA tagged union: a typechecked union of different variants. …\nAn enumeration of a list of possible types. This is a sum …\nAn environment under which expressions and types are …\nAn LIR compilation error.\nTODO: Add variants for <code>LetProc</code>, <code>LetVar</code>, etc. to support …\nA foreign function declaration.\nA typed procedure which calls a foreign function. This is …\nA foreign function interface binding.\nA constant floating point value.\nThe floating-point number type.\nImport an element from a module.\nGet the size of something in memory (number of cells).\nGet the type associated with a value under a given …\nAn if-then-else expression.\nAn if-let expression.\nImmutable access to a value. This is the default way to …\nDeclare associated constants and procedures for a type.\nIndex an array or pointer with an expression that …\nA constant integer value.\nThe integer type.\nInvalid type casting expression.\nInvalid assignment operation (assign, add_assign, …\nInvalid assign op types (incorrect types).\nInvalid binary operation (add, subtract, and, or) …\nInvalid binary op types (incorrect types).\nInvalid constant expression.\nInvalid <code>Index</code> expression (incorrect types).\nTried to match over an expression that cannot be matched …\nCannot monomorphize a constant expression.\nTried to use a pattern that is not valid for the given …\nTried to use a pattern that is not valid for the given …\nInvalid <code>Refer</code> expression. The compiler was not able to …\nInvalid number of template arguments to a type.\nInvalid ternary operation (if) expression (incorrect …\nInvalid ternary op types (incorrect types).\nInvalid unary operation (negate, not) expression …\nInvalid unary op types (incorrect types).\nAn annotation for live code.\nBind a type to a name in a temporary scope.\nThe source code location of the expression.\nMany annotations can be attached to an expression. This is …\nMany declarations.\nA block of expressions. The last expression in the block …\nA match expression.\nGet an attribute of a constant expression.\nGet a field or member from a structure, union, or tuple. …\nTried to access an undefined member of a tuple, struct, or …\nMismatched mutability\nMismatched types\nDeclare a module\nTried to define a module that already exists.\nMonomorphize a constant expression with some type …\nMutability of a pointer. This is used to provide type …\nMutable access to a value.\nA constant expression that evaluates to <code>None</code>. This …\nTried to create an array with a negative length.\nThe type of an expression that will never return, or doesn…\nInvalid pattern for a match expression.\nGot another type when expecting an integer, bool, or char.\nExpected a symbol, but got something else.\nNo annotation.\nThe unit, or “void” instance.\nThe type of void expressions.\nA boolean “Not” operation on a value.\nThe null pointer constant.\nA constant enum variant.\nA boolean “Or” operation between two values.\nA pattern which can be matched against an expression.\nA pointer to another type.\nA polymorphic, parametric type. This type is used with the …\nA polymorphic procedure.\nA polymorphic procedure declaration.\nA polymorphic procedure of LIR code which can be applied …\nA procedure.\nA procedure declaration.\nA procedure with a list of parameters and a return type.\nA monomorphic procedure of LIR code which can be applied …\nPrint a value to a given output.\nRecursion depth exceeded when trying to evaluate a …\nRecursion depth exceeded when trying to confirm a type’s …\nReference this expression (i.e. get a pointer to it).\nReturn a value from a function.\nThis is the maximum number of times a type will be …\nSimplify an expression while maintaining structural …\nGet the size of an expression’s type (in cells) as a …\nTried to get the size of a template type.\nGet the size of a type (in cells) as a constant int.\nA builtin pseudo-procedure implemented in the standard …\nA builtin implemented in handwritten standard assembly.\nA static variable declaration.\nA structure of constant values.\nA structure of fields to expressions.\nA tuple with named members. This is a product type.\nA named constant.\nA named type.\nA symbol was used, but not defined.\nAn annotation for a temporary.\nGet the Enum value of the tag associated with a tagged …\nIs this expression a temporary?\nA trait used to implement a ternary operation.\nPerform a ternary operation on three expressions.\nA tuple of constant values.\nA tuple of expressions.\nA heterogenous collection of types. This is a product type.\nThe representation of a type in the LIR type system.\nA type as a constant expression.\nA type declaration.\nA trait object. This is internally represented as an …\nA trait used to enforce type checking.\nA type was used, but not defined.\nGet the type of an expression. (as an array of chars)\nTried to define a type that already exists.\nAn annotation for user-generated code.\nA trait used to implement a unary operation.\nPerform a unary operation on two expressions.\nAn error caused by unexpectedly passing a constant …\nA union of constant values.\nA union: a collection of named fields. The <code>Type</code> value is …\nA union of a list of possible types mapped to named …\nThis type is identified by its name. Most types are …\nTried to instantiate a type that cannot be sized. This is …\nExpression uses an operation unsupported by the target.\nUnused expression returned a non-None value.\nA variable declaration.\nA variable declaration with a pattern.\nThe variant of an enum is not defined.\nA constant, compile time if-then-else expression.\nCreate a while loop: while the first expression evaluates …\nAdd this expression to another.\nAdd monomorphized methods for a given monomorph of a …\nConstruct a new pattern which binds to several alternate …\nLogical and this expression with another.\nAnnotate an error with some metadata.\nAnnotate this constant expression with a source code …\nAn annotated expression with some metadata.\nApply this procedure or builtin to a list of expressions …\nApply this expression as a procedure to some arguments.\nApply this template type with some type arguments.\nThis associated function returns whether or not a set of …\nThe arguments of the builtin. These will be typechecked …\nThe arguments of the builtin. These will be typechecked …\nTry to get this constant expression as a boolean value.\nTry to get this constant expression as a character.\nTry to get this constant expression as a float.\nTry to get this constant expression as an integer.\nTry to get this constant expression as a symbol (like in …\nCast an expression as another type.\nCast an expression as another type.\nPerform an AssignOp on this expression.\nPerform an AssignOp on this expression.\nBitwiseAnd this expression with another.\nBitwiseOr this expression with another.\nBitwiseAnd this expression with another.\nBitwiseAnd this expression with another.\nBitwiseOr this expression with another.\nBitwise this expression with another.\nThe list of assembly instructions to be pasted into the …\nThe list of assembly instructions to be pasted into the …\nConstruct a new pattern which matches a constant boolean.\nChecks if the operation can be applied to the given types.\nChecks if the operation can be applied to the given type.\nChecks if the operation can be applied to the given types.\nChecks if the operation can be applied to the given types.\nCan this binary operation be applied to the given types?\nCan this binary operation be applied to the given types?\nCan this binary operation be applied to the given types?\nCan this binary operation be applied to the given types?\nCan this binary operation be applied to the given types?\nCan this binary operation be applied to the given types?\nCan this binary operation be applied to the given types?\nCan this binary operation be applied to the given types?\nCan this unary operation be applied to the given type?\nCan this unary operation be applied to the given type?\nCan this binary operation be applied to the given types?\nCan this binary operation be applied to the given types?\nCan this unary operation be applied to the given type?\nCan this unary operation be applied to the given type?\nCan this unary operation be applied to the given type?\nCan this unary operation be applied to the given type?\nCan this unary operation be applied to the given type?\nChecks if the operation can be applied to the given …\nChecks if the operation can be applied to the given …\nChecks if the operation can be applied to the given …\nChecks if the operation can be applied to the given …\nChecks if the operation can be applied to the given …\nChecks if the operation can be applied to the given …\nChecks if the operation can be applied to the given …\nChecks if the operation can be applied to the given …\nCan this type be cast to another type?\nCan a pointer of this mutability decay to a pointer of …\nCan this type decay into another type?\nClones the operation into a boxed trait object.\nClones the operation into a boxed trait object.\nClones the operation into a boxed trait object.\nClones the operation into a boxed trait object.\nClone this operation into a trait object.\nClone this binary operation into a box.\nClone this binary operation into a box.\nClone this binary operation into a box.\nClone this binary operation into a box.\nClone this binary operation into a box.\nClone this operation into a box.\nClone this operation into a box.\nClone this binary operation into a box.\nClone this operation into a box.\nClone this operation into a box.\nClone this operation into a box.\nClone this operation into a box.\nClone this operation into a box.\nClone this operation into a box.\nCompile the expression into an assembly program.\nCompile the expression into an assembly program.\nCompiles the operation on the given expressions.\nCompiles the operation on the given expressions.\nCompiles the operation on the given expression.\nCompiles the operation on the given expression.\nCompiles the operation on the given expressions.\nCompiles the operation on the given expressions.\nCompiles the operation on the given expressions.\nCompiles the operation on the given expressions.\nCompiles the operation on the given expressions.\nCompiles the operation on the given expressions.\nCompile the assignment operation.\nCompile a list of arguments, accounting for the fact that …\nCompiles the operation on the given types. (Generates the …\nCompiles the operation on the given type. (Generates the …\nCompiles the operation on the given types. (Generates the …\nCompiles the operation on the given types. (Generates the …\nCompile the binary operation.\nCompile the assignment operation.\nCompile the binary operation.\nCompile the binary operation.\nCompile the binary operation.\nCompile the binary operation.\nCompile the binary operation.\nCompile the binary operation.\nCompile the unary operation.\nCompile the unary operation.\nCompile the binary operation.\nCompile the binary operation.\nCompile the unary operation.\nCompile the unary operation.\nCompile the unary operation.\nCompile the unary operation.\nCompile the unary operation.\nDoes this type contain a symbol with the given name? This …\nLet-bind the pattern to the given expression. This will …\nDefine multiple types with the given names under this …\nDefine a variable in the current scope. This will …\nDereference this expression (i.e. get the value it points …\nDereference this expression (i.e. get the value it points …\nFormats the operation for display.\nFormats the operation for display.\nFormats the operation for display.\nFormats the operation for display.\nFormats the operation for display.\nFormats the operation for display.\nFormats the operation for display.\nFormats the operation for display.\nDivide this expression by another.\nIs this expression greater than another?\nAre two types structurally equal?\nEvaluates the operation on the given constant expressions.\nEvaluates the operation on the given constant expression.\nEvaluates the operation on the given constant expressions.\nEvaluates the operation on the given constant expressions.\nEvaluate this constant expression at compile time, and get …\nEvaluate this binary operation on the given constant …\nEvaluate this binary operation on the given constant …\nEvaluate this binary operation on the given constant …\nEvaluate this binary operation on the given constant …\nEvaluate this binary operation on the given constant …\nEvaluate this binary operation on the given constant …\nEvaluate this binary operation on the given constant …\nEvaluate this binary operation on the given constant …\nEvaluate this unary operation on the given constant values.\nEvaluate this unary operation on the given constant values.\nEvaluate this binary operation on the given constant …\nEvaluate this binary operation on the given constant …\nEvaluate this unary operation on the given constant values.\nEvaluate this unary operation on the given constant values.\nEvaluate this unary operation on the given constant values.\nEvaluate this unary operation on the given constant values.\nEvaluate this unary operation on the given constant values.\nGet a field from a structure, union, or tuple.\nGet a field from a structure, union, or tuple.\nConstruct a new pattern which matches a constant float.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIs this expression greater than or equal to another?\nGet the arguments of the procedure.\nGet the map of new variables and their types which are …\nGet the body of the procedure.\nGet the type of a branch with a given expression matched …\nGet the name of the procedure known to the LIR front-end.\nGet the mangled name of the procedure. The procedure’s …\nGet the template arguments for the monomorph (this type) …\nGet the name of this polymorphic procedure. This is not …\nGet the return type of the procedure.\nGet the first argument’s mutability (if it is a pointer)\nGet the size of something in memory (number of cells).\nGet the size of something in memory (number of cells).\nGet the size of something in memory, but limit the number …\nGet the template parameters for this template type.\nGet the type associated with a value under a given …\nGet the type associated with a value under a given …\nGet the type of a value under a given environment and check\nGet the type of an associated constant of a type.\nIs this expression greater than another?\nDoes this type have an element type matching the supplied …\nDoes this annotation have a location?\nIndex an array or pointer with an expression that …\nGenerate an <code>if let</code>expression, which matches a given <code>expr</code>, …\nCreate an if-then-else statement with this expression as …\nConstruct a new pattern which matches a constant integer.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this type an irreducible, atomic type?\nIs this compiler-generated?\nIs this type simplified enough to get information about …\nIs this type a constant parameter?\nIs this data protected against mutation?\nIs this dead code?\nIs this pattern exhaustive?\nIs this annotation a location?\nIs this type a monomorph of a given template type?\nCan this data be accessed mutably?\nIs this annotation none?\nIs this a polymorphic function?\nIs this type recursive?\nIs first argument of function a reference?\nIs this type in a simple form? A simple form is a form …\nIs this a temporary?\nIs this expression less than or equal to another?\nCreate a let-bound type.\nCreate a <code>let</code> binding for a constant expression.\nCreate several <code>const</code> bindings at onces.\nCreate a <code>proc</code> binding for a procedure.\nCreate several <code>proc</code> bindings at onces.\nCreate a <code>let</code> binding for an type.\nCreate several <code>type</code> bindings at onces.\nCreate a <code>let</code> binding for an expression.\nCreate a <code>let</code> binding for an expression, and define …\nGet the location of this annotation.\nIs this expression less than another?\nCreate a collection of declarations\nGenerate an expression which evaluates a <code>match</code> expression, …\nCreate a module with a given name and a list of …\nTake some type arguments and produce a monomorphized …\nMultiply this expression by another.\nThe name of the builtin. This isn’t used in compilation, …\nThe name of the builtin. This isn’t used in compilation, …\nGet the remainder of this expression divided by another.\nIs this expression greater than or equal to another?\nCreate a new assignment operation.\nCreate a new FFI procedure.\nConstruct a new procedure with a given list of arguments …\nConstruct a new polymorphic procedure with type …\nLogical not this expression.\nLogical or this expression with another.\nPerform type applications if possible.\nConstruct a new pattern which matches a pointer.\nGet the power of this expression to another.\nConstruct a procedure.\nPush this procedure’s label to the stack.\nReference this expression (i.e. get a pointer to it).\nGet the remainder of this expression divided by another.\nThe return value the builtin will leave on the stack after …\nThe return value the builtin will leave on the stack after …\nGets the type of the operation on the given expressions.\nGets the type of the operation on the given expressions.\nGets the type of the operation on the given expression.\nGets the type of the operation on the given expression.\nGets the type of the operation on the given expressions.\nGets the type of the operation on the given expressions.\nGets the type of the operation on the given expressions.\nGets the type of the operation on the given expressions.\nGet the type of the result of applying this binary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this unary …\nGet the type of the result of applying this unary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this binary …\nGet the type of the result of applying this unary …\nGet the type of the result of applying this unary …\nGet the type of the result of applying this unary …\nGet the type of the result of applying this unary …\nGet the type of the result of applying this unary …\nThis is just for debugging purposes. This sets the common …\nSimplify an expression while maintaining structural …\nSimplify an expression while maintaining structural …\nSimplify until the type is concrete.\nSimplify until the type is concrete.\nSimplify a type until you can get its members.\nSimplify a type until you can get its variants.\nSimplify an expression until it matches a given function …\nSimplify until the type is a polymorphic type.\nSimplify until the type passes the type checker.\nSimplify a type until it’s a union.\nGet the size of an expression.\nStrip the template arguments to get the inner type\nConstruct a new pattern which matches a struct with a …\nCreate a structure of fields to expressions.\nSubtract an expression from this expression.\nSubstitute a type for a given name in the environment.\nSubstitute a type in a given expression.\nSubstitute all occurences of a symbol with another type. …\nConstruct a new pattern which matches a symbol with a …\nConstruct a new pattern which matches a tuple of patterns.\nType check the expression.\nTypechecks the operation on the given expressions.\nTypechecks the operation on the given expressions.\nTypechecks the operation on the given expression.\nTypechecks the operation on the given expression.\nTypechecks the operation on the given expressions.\nTypechecks the operation on the given expressions.\nTypechecks the operation on the given expressions.\nTypechecks the operation on the given expressions.\nType-check a pattern match of an expression against this …\nApply a unary operation to this expression.\nEvaluate a variable in the current scope.\nEvaluate a variable in the current scope.\nCalculate the integral value of a variant in an enum.\nCreate a while statement with this expression as the …\nConstruct a new pattern which matches any expression.\nReturn this expression, but with a given declaration in …\nReturn this expression, but with a given declaration in …\nA struct representing a location in the source code. This …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse Core and Standard variants of assembly source code. …\nParse frontend sage code into an LIR expression.\nParse LIR code as an LIR expression.\nParse Core and Standard variants of virtual machine source …\nForeign Function Interface\nI/O Module\nThis is an FFI binding, which is used to call a foreign …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new FFI binding.\nInput from an accelerometer (in meters per second per …\nInput from altitude sensor (in meters)\nElectrical device input modes (These should typically be …\nElectrical device output modes Set the voltage of a given …\nThe different axes an input or output might use.\nInput from a barometer (pressure in atmospheres)\nRing a bell (in hertz)\nBlack\nSet the pressure of a given blower (in atmospheres)\nBlue\nBlue light intensity (in lux)\nInput from a light sensor (in lux)\nLighting device output modes Set the brightness of a given …\nInput from a button (0=not pressed, 1=pressed)\nSound output modes Ring a given buzzer (in hertz)\nThe channel to use for a given I/O mode.\nClear the display\nPhysical sensor input modes (These should typically be …\nThe different output colors a program might use.\nInput from a compass (degrees)\nInput from a conductivity sensor (in siemens per meter)\nTurn a cooler on or off (0=off, 1=on)\nCustom output modes A custom input mode (for use with a …\nCustom output modes A custom output mode (for use with a …\nCyan\nUser input modes (These should typically be used for games …\nInput from depth sensor (in meters)\nInput from a digital input (0=low, 1=high)\nSet the state of a given digital output (0=low, 1=high)\nThe different directions a D-Pad a might use.\nSet the pressure of a given fan (in atmospheres)\nInput from a flow sensor (in liters per second)\nGreen\nGreen light intensity (in lux)\nInput from a gyroscope (in degrees per second) around a …\nTurn a heater on or off (0=off, 1=on)\nInput from a humidity sensor (in percent)\nAn input source for a program.\nThe different types of input modes a program might use.\nInput from a JoyStick the degree of displacement in a …\nInput from keyboard (ASCII character)\nMagenta\nInput from a magnetometer (in teslas) in a given axis\nInput from a microphone (frequency in hertz)\nSet the speed of a given motor (in revolutions per minute)\nMove the cursor down on the display\nMove the cursor left on the display\nMove the cursor right on the display\nMove the cursor up on the display\nPlay a given note (in hertz)\nInput from an odometer (in meters)\nOrange\nAn output destination for a program.\nThe different types of output modes a program might use.\nInput from a pH sensor (in pH)\nInput from a position sensor in a given axis (x, y, z)\nSet the pressure of a given vacuum/pressurizer …\nEngineering / Science sensor input modes Input from a …\nAlternative output modes for standard output Printer …\nPrinter (float)\nPrinter (integer)\nInput from a distance sensor (in meters)\nSet the pressure of a given pump (in atmospheres)\nRGB\nInput from a rain gauge (in millimeters)\nSpecial input modes A random number\nRed\nEnvironment sensor input modes (These should typically be …\nSet the position of a given servo (in radians)\nWrite a character to the display\nSet the cursor column on the display\nSet the color of a given pixel on the display\nSet the cursor row on the display\nSet the polarity of a solenoid (0=off, 1=on)\nSet the frequency of a given speaker (in hertz)\nSet the volume of a given speaker (in percent)\nNavigation input modes (These should typically be …\nStandard error (ASCII character)\nStandard error (float)\nStandard error (integer)\nStandard input modes (The standard interface is typically …\nStandard input (float)\nStandard input (integer)\nStandard output modes Standard output (ASCII character)\nStandard output (float)\nStandard output (integer)\nRobotics device output modes Set the position of a given …\nSet the temperature of a given heating/cooling device …\nInput from a thermometer (degrees K)\nInput from a UV sensor (in watts per square meter)\nDisplay output modes Update the display\nSet the position of a given valve (0=closed, 1=open)\nInput from a volume sensor (in liters)\nInput from a weight sensor (in kilograms)\nWhite\nInput from a wind direction sensor (in degrees)\nInput from a wind speed sensor (in meters per second)\nYellow\nThe channel to use for the input.\nThe channel to use for the output.\nThe time (in seconds) since the program started\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe mode of the input.\nThe mode of the output.\nCreate a new input source.\nCreate a new output destination.\nA random number\nOutput to STDERR (ASCII character)\nOutput to STDERR (float)\nOutput to STDERR (integer)\nInput from STDIN (ASCII character)\nInput from STDIN (float)\nInput from STDIN (integer)\nOutput to STDOUT (ASCII character)\nOutput to STDOUT (float)\nOutput to STDOUT (integer)\nA trait for a target architecture to be compiled to.\nImplement a compiler for the given target.\nCompile the core variant of the machine code (must be …\nCompile the standard variant of the machine code (should …\nC Target\nCompile the declaration of a procedure.\nCompile an <code>End</code> instruction (with the matching <code>If</code> or <code>While</code> …\nGet a value from the given input stream (mode + channel).\nThe string used for indentation.\nThe name of the target architecture.\nCompile a <code>CoreOp</code> instruction.\nPeek a value from the device connected to the program.\nPoke a value to the device connected to the program.\nThe code after the function definitions.\nThe code after the program ends.\nThe code after each instruction.\nThe code before the function definitions.\nThe code before the program starts.\nPut a value to the given output stream (mode + channel).\nC Target\nCompile a <code>StandardOp</code> instruction.\nWhether or not the target architecture supports floating …\nWhether or not the target architecture supports the given …\nWhether or not the target architecture supports the given …\nThe version of the target architecture.\nThe type for the C target which implements the <code>Target</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe type for the C target which implements the <code>Target</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStore the inverse-cosine of the register (as a float) into …\nStore the inverse-sine of the register (as a float) into …\nStore the inverse-tangent of the register (as a float) …\nAdd the value pointed to on the tape to the register. The …\nAdd the value pointed to on the tape to the register (as …\nTake the value of the register, and allocate that number …\nBoolean-and the register and the value pointed to on the …\nInterpret the register’s value as a signed integer. …\nPerform bitwise and on the cell and the value pointed to …\nPerform bitwise nand on the cell and the value pointed to …\nBitwise not the register. Store the result in the register.\nPerform bitwise or on the cell and the value pointed to on …\nPerform a bitwise xor on the cell and the value pointed to …\nCalls the nth function defined in the program, where n is …\nCall a foreign function interface function.\nA comment in the machine code (not in the compiled output).\nThe interpreter which runs the virtual machine program.\nAn individual core virtual machine instruction.\nExecute a core instruction.\nA program of only core virtual machine instructions.\nStore the cosine of the register (as a float) into the …\nDecrement the register.\nThe pointer is made equal to the value pointed to on the …\nCreate an input / output device for the virtual machine …\nDivide the register by the value pointed to on the tape. …\nDivide the register by the value pointed to on the tape …\nBegin an “else” conditional.\nEnd a conditional.\nAn error generated by the virtual machine.\nWhen the virtual machine attempts to get the program as …\nFree the memory pointed to by the register.\nCreate a new function.\nGet a value from an input source and store it in the …\nBegin an “if the register is not zero” conditional.\nIncrement the register. The argument is the size of the …\nInterpret the register’s value as a pointer to a cell. …\nMake the register equal to 1 if the register is …\nMake the register equal to the integer 1 if the register …\nLeft shift the cell by the value pointed to on the tape. …\nStore the value pointed to on the tape to the register.\nLogical right shift the cell by the value pointed to on …\nMove the pointer on the tape by a number of cells.\nMultiply the register by the value pointed to on the tape. …\nMultiply the register by the value pointed to on the tape …\nNegate the register. The argument is the size of the …\nNegate the value of the register (as a float).\nBoolean-not the register (0 if the register is non-zero, 1 …\nInterpret the register’s value as a pointer to a cell. …\nBoolean-or the register and the value pointed to on the …\nGet a value from the input interface / device and store it …\nWrite the value of the register to the output interface / …\nStore the value of the register (as a float) to the power …\nWrite the value of the register to an output source.\nThe last “deref” operation is undone; the pointer is …\nStore the remainder of the register and the value pointed …\nStore the remainder of the register and the value pointed …\nReturn from the current function.\nSet the register equal to a constant value.\nSet the register equal to a constant floating point value.\nStore the sine of the register (as a float) into the …\nA device used for standard input and output. This simply …\nThe interpreter which runs the standard variant of virtual …\nAn individual standard virtual machine instruction.\nA program of core and standard virtual machine …\nStore the register to the value pointed to on the tape.\nSubtract the value pointed to on the tape from the …\nSubtract the value pointed to on the tape from the …\nSwap the value of the register with the value pointed to …\nStore the tangent of the register (as a float) into the …\nA device used for testing the compiler. This simply keeps …\nConvert the register from an integer to a float.\nConvert the register from a float to an integer.\nWhen an instruction is unsupported for a given …\nAn interface to conveniently create virtual machine …\nStore the value of the pointer to the register.\nBegin a “while the register is not zero” loop.\nA function to reinterpret the bits of an integer as a …\nA function to reinterpret the bits of a float as an …\nFFI call to the device. This will get the FFI binding for …\nFlatten a core program so that all of its functions are …\nFlatten a core program so that all of its functions are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the next input (from a given input source).\nGet the code for each function.\nGet the code for each function.\nGet the code outside of any functions.\nGet the code outside of any functions.\nGet the code outside of any functions, and the code for …\nGet the code outside of any functions, and the code for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new testing device with some given sample input.\nGet the output of the testing device as a string (ascii).\nPeek at the next value in the FFI buffer for the FFI …\nPoke a value into the FFI buffer for the FFI function …\nPut the given value to the given output destination.\nRun a core program using this interpreter and its device.\nRun a core program using this interpreter and its device.")
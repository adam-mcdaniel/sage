<!DOCTYPE html>

<html>
    <head>
        <title>hello-wasm example</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js" integrity="sha512-8RnEqURPUc5aqFEN04aQEiPlSAdE0jlFS/9iGgUyNtwFnSKCXhmB6ZTNl7LnDtDWKabJIASzXrzD0K+LYexU9g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css" integrity="sha512-uf06llspW44/LZpHzHT6qBOIVODjWtv4MxCricRxkzvopAlSWnTf6hpZTFxuuZcuNE9CBQhqE0Seu1CoRk84nQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/mode/simple.min.js" integrity="sha512-CGM6DWPHs250F/m90YZ9NEiEUhd9a4+u8wAzeKC6uHzZbYyt9/e2dLC5BGGB6Y0HtEdZQdSDYjDsoTyNGdMrMA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/rust/rust.min.js" integrity="sha512-g3Nhw36S0p4ZJQcky87D5M+vZbFvLrgsHWYltUy5IW0zKbvi8GlPRjJSo2CyUyQiU01Ier7u+rBABDs3BawKyQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/clike/clike.min.js" integrity="sha512-l8ZIWnQ3XHPRG3MQ8+hT1OffRSTrFwrph1j1oc1Fzc9UKVGef5XN9fdO0vm3nW0PRgQ9LJgck6ciG59m69rvfg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/ayu-dark.min.css" integrity="sha512-mV3RUXi1gt22jDb4UyRBFhZVFgAIiOfRE6ul+2l1Hcj6glyg6x4xlnjPH+neGm/t6XrFmsMRu4++McQu0asjqg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <style>
            .CodeMirror {
                border: 1px solid #eee;
                height: 100%;
            }
        </style>
    </head>
    <body style="height: 100%">
        <script type="module">
            import init, {compile_and_run} from './web.js';
            init();
            
            var source = CodeMirror.fromTextArea(document.getElementById("source"), {
                mode: "rust",
                lineNumbers: true,
                indentUnit: 4,
                theme: 'ayu-dark',
                autoRefresh: true,
            });
            source.setSize("100%", "40em");
            setInterval(function () {
                document.getElementById("source").value = source.getValue();
                source.refresh()
            }, 50);
            var output = CodeMirror.fromTextArea(document.getElementById("output"), {
                mode: "text/x-csrc",
                lineNumbers: true,
                indentUnit: 4,
                theme: 'ayu-dark',
                autoRefresh: true,
            });
            output.setSize("100%", "100%");
            setInterval(function () {
                if (output.getValue() != document.getElementById("output").value) {
                    output.setValue(document.getElementById("output").value);
                    output.refresh()
                }
            }, 50);
            function setExampleProgram() {
                console.log(document.getElementById("example").value);
                switch (document.getElementById("example").value) {
                case "aes":
                    source.setValue(`const bitxor = proc(a: Int, b: Int) -> Int = core {
    bitwise-xor [SP], [SP - 1] pop
}, bitor = proc(a: Int, b: Int) -> Int = core {
    bitwise-or [SP], [SP - 1] pop
}, bitnand = proc(a: Int, b: Int) -> Int = core {
    bitwise-nand [SP], [SP - 1] pop
}, bitand = proc(a: Int, b: Int) -> Int = core {
    bitwise-and [SP], [SP - 1] pop
}, bitnot = proc(x: Int) -> Int = core {
    bitwise-not [SP]
}, lt = proc(a: Int, b: Int) -> Bool = core {
    lt [SP - 1], [SP], A pop
    mov A, [SP]
}, gt = proc(a: Int, b: Int) -> Bool = core {
    gt [SP - 1], [SP], A pop
    mov A, [SP]
}, eq = proc(a: Int, b: Int) -> Bool = core {
    eq [SP - 1], [SP], A pop
    mov A, [SP]
}, neq = proc(a: Int, b: Int) -> Bool = core {
    neq [SP - 1], [SP], A pop
    mov A, [SP]
}, putinch = proc(n: Int) -> None = core {
    put-char [SP]
    pop
} in

proc putdec(n: Int) -> None = {
    if (lt(n, 10)) {
        putinch(n + 48)
    } else {
        putdec(n / 10);
        putinch(n % 10 + 48)
    }
} in

proc puthex(n: Int, lower: Bool) -> None = {
    if (lt(n, 16)) {
        putinch(n + if (lt(n, 10)) {
            48
        } else {
            if lower {
                87
            } else {
                55
            }
        })
    } else {
        puthex(n / 16, lower);
        puthex(n % 16, lower)
    }
} in

proc putbyte(n: Int, lower: Bool) -> None = {
    puthex(n / 16, lower);
    puthex(n % 16, lower)
} in

const putint = proc(n: Int) -> None = { putbyte(n, false) } in

const putchar = proc(ch: Char) -> None = {
    putinch(ch as Int)
} in

const getchar = proc() -> Char = core {
    next SP
    get-char [SP]
} in

proc ln() -> None = {
    putchar('\n')
} in

proc lsh(a: Int, b: Int) -> Int = {
    while b {
        a = a * 2;
        b = b - 1;
    };
    a
} in

proc rsh(a: Int, b: Int) -> Int = {
    let added = -2147483648, i = 0, negative = lt(a, 0) in {
        while (lt(i, b - 1)) {
            added = added / 2;
            i = i + 1;
        };
        if negative { a = bitnot(a) };
        while b {
            a = a / 2;
            b = b - 1;
        };
        if negative { a = bitxor(bitnot(a), added) };
    };
    a
} in

proc xtime(n: Int) -> Int = {
    n = bitand(n, 255) * 2;
    if (lt(n, 256)) n
    else (bitxor(n, 27))
} in

proc mul(a: Int, b: Int) -> Int = {
    a = bitand(a, 255);
    b = bitand(b, 255);
    let result = 0,
        next_term = a,
        i = 0 in {
        while (lt(i, 8)) {
            if (bitand(rsh(b, i), 1)) {
                result = bitxor(result, next_term);
            };
            next_term = xtime(next_term);
            i = i + 1;
        };
        bitand(result, 255)
    }
} in

type State = [Int * 16] in

proc row_major(c0r0: Int, c1r0: Int, c2r0: Int, c3r0: Int,
    c0r1: Int, c1r1: Int, c2r1: Int, c3r1: Int,
    c0r2: Int, c1r2: Int, c2r2: Int, c3r2: Int,
    c0r3: Int, c1r3: Int, c2r3: Int, c3r3: Int
) -> State = {[
    c0r0,
    c0r1,
    c0r2,
    c0r3,

    c1r0,
    c1r1,
    c1r2,
    c1r3,

    c2r0,
    c2r1,
    c2r2,
    c2r3,

    c3r0,
    c3r1,
    c3r2,
    c3r3,
]} in

proc col_major(c0r0: Int, c0r1: Int, c0r2: Int, c0r3: Int,
    c1r0: Int, c1r1: Int, c1r2: Int, c1r3: Int,
    c2r0: Int, c2r1: Int, c2r2: Int, c2r3: Int,
    c3r0: Int, c3r1: Int, c3r2: Int, c3r3: Int,
) -> State = {[
    c0r0,
    c0r1,
    c0r2,
    c0r3,

    c1r0,
    c1r1,
    c1r2,
    c1r3,

    c2r0,
    c2r1,
    c2r2,
    c2r3,

    c3r0,
    c3r1,
    c3r2,
    c3r3,
]} in

proc get(self: &State, x: Int, y: Int) -> Int = {
    self[0][x + y * 4]
} in

proc set(self: &State, x: Int, y: Int, val: Int) -> None = {
    self[0][x + y * 4] = val;
} in

proc putstate(self: State) -> None = {
    let i = 0, j = 0 in {
        while lt(i, 4) {
            while lt(j, 4) {
                putint(get(&self, j, i)); putchar(' ');
                j = j + 1;
            }; putchar('\n');
            j = 0;
            i = i + 1;
        }
    }
} in

proc rot_row(self: State, y: Int, n: Int) -> State = {
    while n {
        let a = get(&self, 0, y),
            b = get(&self, 1, y),
            c = get(&self, 2, y),
            d = get(&self, 3, y) in {
            set(&self, 0, y, b);
            set(&self, 1, y, c);
            set(&self, 2, y, d);
            set(&self, 3, y, a);
        };
        n = n - 1;
    };
    self
} in

proc shift_rows(self: State) -> State = {
    rot_row(rot_row(rot_row(self, 1, 1), 2, 2), 3, 3)
} in

proc inverse_shift_rows(self: State) -> State = {
    rot_row(rot_row(rot_row(self, 1, 3), 2, 2), 3, 1)
} in

proc add_round_key(self: State, round_key: State) -> State = {
    let i = 0 in {
        while lt(i, 16) {
            ((&self) as &Int)[i] = bitxor(((&self) as &Int)[i], ((&round_key) as &Int)[i]);
            i = i + 1;
        };
        self
    }
} in

proc mix_columns(self: State) -> State = {
    let j = 0 in while lt(j, 4) {
        let s0 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 2), mul(get(&self, j, 1), 3)), get(&self, j, 2)), get(&self, j, 3)),
            s1 = bitxor(bitxor(bitxor(get(&self, j, 0), mul(get(&self, j, 1), 2)), mul(get(&self, j, 2), 3)), get(&self, j, 3)),
            s2 = bitxor(bitxor(bitxor(get(&self, j, 0), get(&self, j, 1)), mul(get(&self, j, 2), 2)), mul(get(&self, j, 3), 3)),
            s3 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 3), get(&self, j, 1)), get(&self, j, 2)), mul(get(&self, j, 3), 2)) in {
            
            set(&self, j, 0, s0);
            set(&self, j, 1, s1);
            set(&self, j, 2, s2);
            set(&self, j, 3, s3);
        };
        j = j + 1;
    };
    self
} in

proc inverse_mix_columns(self: State) -> State = {
    let j = 0 in while lt(j, 4) {
        let s0 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 14), mul(get(&self, j, 1), 11)), mul(get(&self, j, 2), 13)), mul(get(&self, j, 3), 9)),
            s1 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 9),  mul(get(&self, j, 1), 14)), mul(get(&self, j, 2), 11)), mul(get(&self, j, 3), 13)),
            s2 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 13), mul(get(&self, j, 1), 9)),  mul(get(&self, j, 2), 14)), mul(get(&self, j, 3), 11)),
            s3 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 11), mul(get(&self, j, 1), 13)), mul(get(&self, j, 2), 9)),  mul(get(&self, j, 3), 14)) in {
            
            set(&self, j, 0, s0);
            set(&self, j, 1, s1);
            set(&self, j, 2, s2);
            set(&self, j, 3, s3);
        };
        j = j + 1;
    };
    self
} in

proc sub_byte(byte: Int) -> Int = {
    let S_BOX = [[99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118], [202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192], [183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21], [4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117], [9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132], [83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207], [208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168], [81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210], [205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115], [96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219], [224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121], [231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8], [186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138], [112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158], [225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223], [140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]] in {
        byte = bitand(byte, 255);
        let row = bitand(rsh(byte, 4), 15),
            col = bitand(byte, 15) in
            S_BOX[row][col]
    }
} in

proc inverse_sub_byte(byte: Int) -> Int = {
    let INVERSE_S_BOX = [[82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251], [124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203], [84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78], [8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37], [114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146], [108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132], [144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6], [208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107], [58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115], [150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110], [71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27], [252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244], [31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95], [96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239], [160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97], [23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]] in {
        byte = bitand(byte, 255);
        let row = bitand(rsh(byte, 4), 15),
            col = bitand(byte, 15) in
            INVERSE_S_BOX[row][col]
    }
} in


proc sub_bytes(self: State) -> State = {
    let i = 0, j = 0 in {
        while lt(i, 4) {
            while lt(j, 4) {
                set(&self, j, i, sub_byte(get(&self, j, i)));
                j = j + 1;
            };
            j = 0;
            i = i + 1;
        };
    };
    self
} in

proc inverse_sub_bytes(self: State) -> State = {
    let i = 0, j = 0 in {
        while lt(i, 4) {
            while lt(j, 4) {
                set(&self, j, i, inverse_sub_byte(get(&self, j, i)));
                j = j + 1;
            };
            j = 0;
            i = i + 1;
        };
    };
    self
} in

type AESKeyType = enum {AES256, AES192, AES128} in
type AESKeyData = union {
    AES256: [Int * 32],
    AES192: [Int * 24],
    AES128: [Int * 16]
} in
type Key = struct {
    ty: AESKeyType,
    key: AESKeyData
} in

proc get_key_len(key: Key) -> Int = {
    if (eq(key.ty as Int, AES256 of AESKeyType as Int)) 8
    else (if (eq(key.ty as Int, AES192 of AESKeyType as Int)) 6
    else 4)
} in

proc get_key_rounds(key: Key) -> Int = {
    if (eq(key.ty as Int, AES256 of AESKeyType as Int)) 14
    else (if (eq(key.ty as Int, AES192 of AESKeyType as Int)) 12
    else 10)
} in

proc get_key_size(key: Key) -> Int = {
    if (eq(key.ty as Int, AES256 of AESKeyType as Int)) 32
    else (if (eq(key.ty as Int, AES192 of AESKeyType as Int)) 24
    else 16)
} in

proc get_key_data(key: &Key) -> &Int = {
    (&key->key) as &Int
} in

proc putkey(key: Key) -> None = {
    if (eq(key.ty as Int, AES256 of AESKeyType as Int)) {
        putchar('A');
        putchar('E');
        putchar('S');
        putchar('2');
        putchar('5');
        putchar('6');
    } else (if (eq(key.ty as Int, AES192 of AESKeyType as Int)) {
        putchar('A');
        putchar('E');
        putchar('S');
        putchar('1');
        putchar('9');
        putchar('2');
    } else  {
        putchar('A');
        putchar('E');
        putchar('S');
        putchar('1');
        putchar('2');
        putchar('8');
    });
    putchar(' ');
    let i = 0, size = get_key_size(key), data = get_key_data(&key) in 
        while lt(i, size) {
            putint(data[i]);
            i = i + 1;
        }
} in

proc sub_word(word: Int) -> Int = {
    let byte0 = sub_byte(bitand(rsh(word, 24), 255)),
        byte1 = sub_byte(bitand(rsh(word, 16), 255)),
        byte2 = sub_byte(bitand(rsh(word, 8), 255)),
        byte3 = sub_byte(bitand(word, 255)) in
        (lsh(byte0, 24) + lsh(byte1, 16) + lsh(byte2, 8) + byte3)
} in

proc rot_word(word: Int) -> Int = {
    let byte0 = bitand(rsh(word, 24), 255),
        byte1 = bitand(rsh(word, 16), 255),
        byte2 = bitand(rsh(word, 8), 255),
        byte3 = bitand(word, 255) in
        (lsh(byte1, 24) + lsh(byte2, 16) + lsh(byte3, 8) + byte0)
} in

proc word(byte3: Int, byte2: Int, byte1: Int, byte0: Int) -> Int = {
    (lsh(byte3, 24) + lsh(byte2, 16) + lsh(byte1, 8) + byte0)
} in

proc bytes(word: Int) -> [Int * 4] = {
    let byte0 = bitand(rsh(word, 24), 255),
        byte1 = bitand(rsh(word, 16), 255),
        byte2 = bitand(rsh(word, 8), 255),
        byte3 = bitand(word, 255) in
        [byte0, byte1, byte2, byte3]
} in

proc round_key(word0: Int, word1: Int, word2: Int, word3: Int) -> State = {
    let bytes0 = bytes(word0),
        bytes1 = bytes(word1),
        bytes2 = bytes(word2),
        bytes3 = bytes(word3) in
            col_major(bytes0[0], bytes1[0], bytes2[0], bytes3[0],
            bytes0[1], bytes1[1], bytes2[1], bytes3[1],
            bytes0[2], bytes1[2], bytes2[2], bytes3[2],
            bytes0[3], bytes1[3], bytes2[3], bytes3[3])
} in

const alloc = proc(size: Int) -> &Int = std {
    alloc [SP]
} in

const free = proc(ptr: &Int) -> None = std { free[SP] pop } in

proc key_expansion(key: Key, nr: Int, nk: Int) -> &Int = {
    let key_data = get_key_data(&key),
        w: &Int = alloc(4 * (nr + 1) * sizeof(Int)),
        i = 0 in {
        while lt(i, nk) {
            (w[i]) = word(
                key_data[4 * i],
                key_data[4 * i + 1],
                key_data[4 * i + 2],
                key_data[4 * i + 3],
            );
            i = i + 1;
        };

        i = nk;
        let rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54] in {
            while lt(i, 4 * (nr + 1)) {
                let tmp = w[i - 1] in {
                    if (eq(i % nk, 0)) {
                        tmp = bitxor(sub_word(rot_word(tmp)), word(rcon[i / nk - 1], 0, 0, 0));
                    } else {
                        if (eq(nk, 8) and eq(i % nk, 4)) {
                            tmp = sub_word(tmp);
                        }
                    };
                    w[i] = bitxor(w[i - nk], tmp);
                };
                i = i + 1;
            }
        };
        w
    }
} in

proc aes_256_key(key: [Int * 32]) -> Key = {
    struct {
        ty = AES256 of AESKeyType,
        key = union {
            AES256 = key,
            AESKeyData..
        }
    }
} in

proc aes_192_key(key: [Int * 24]) -> Key = {
    struct {
        ty = AES192 of AESKeyType,
        key = union {
            AES192 = key,
            AESKeyData..
        }
    }
} in

proc aes_128_key(key: [Int * 16]) -> Key = {
    struct {
        ty = AES128 of AESKeyType,
        key = union {
            AES128 = key,
            AESKeyData..
        }
    }
} in

proc cipher(self: State, key: Key) -> State = {
    let result = self,
        i = 4,
        len = get_key_len(key),
        rounds = get_key_rounds(key),
        k = key_expansion(key, rounds, len)
        in {

        result = add_round_key(result, round_key(k[0], k[1], k[2], k[3]));
        while lt(i, 4 * (rounds + 1)) {
            let rk = round_key(k[i], k[i + 1], k[i + 2], k[i + 3]) in {
                result = shift_rows(sub_bytes(result));
                if (neq(i / 4, rounds)) {
                    result = mix_columns(result);
                };
                result = add_round_key(result, rk);
            };
            i = i + 4;
        };
        free(k);
        result
    }
} in

proc inverse_cipher(self: State, key: Key) -> State = {
    let result = self,
        len = get_key_len(key),
        rounds = get_key_rounds(key),
        i = 4 * rounds,
        k = key_expansion(key, rounds, len)
        in {

        while gt(i, 0) {
            let rk = round_key(k[i], k[i + 1], k[i + 2], k[i + 3]) in {
                result = add_round_key(result, rk);
                if (neq(i / 4, rounds)) {
                    result = inverse_mix_columns(result);
                };
                result = inverse_sub_bytes(inverse_shift_rows(result));
            };
            i = i - 4;
        };
        result = add_round_key(result, round_key(k[0], k[1], k[2], k[3]));
        free(k);
        result
    }
} in

proc between(lower: Int, n: Int, upper: Int) -> Bool = {
    if (lt(n, lower)) {
        return false
    };

    if (gt(n, upper)) {
        return false
    };

    true
} in

proc gethexdigit() -> Int = {
    let digit = getchar() as Int in
        if (between(48, digit, 57)) {
            digit - 48
        } else (if (between(65, digit, 70)) {
            digit - 55
        } else (if (between(97, digit, 102)) {
            digit - 87
        } else {
            0
        }))
} in

proc getbyte() -> Int = {
    gethexdigit() * 16 + gethexdigit()
} in

let state = row_major(
    0, 1, 2, 3,
    4, 5, 6, 7,
    8, 9, 10, 11,
    12, 13, 14, 15
) in {
    let key = aes_128_key([
        0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 10, 11, 12, 13, 14, 15,
    ]) in {
        putchar('k');
        putchar('e');
        putchar('y');
        putchar(':');
        putchar(' ');
        putchar('\n');
        putkey(key);
        putchar('\n');

        putchar('i');
        putchar('n');
        putchar('p');
        putchar('u');
        putchar('t');
        putchar(':');
        putchar('\n');
        putstate(state);

        state = cipher(state, key);
        putchar('o');
        putchar('u');
        putchar('t');
        putchar('p');
        putchar('u');
        putchar('t');
        putchar(':');
        putchar('\n');
        putstate(state);
        state = inverse_cipher(state, key);

        putchar('i');
        putchar('n');
        putchar('v');
        putchar('e');
        putchar('r');
        putchar('s');
        putchar('e');
        putchar(':');
        putchar('\n');
        putstate(state);
    };
}`);
                    break;
                case "quicksort":
                    source.setValue(`const bitxor = proc(a: Int, b: Int) -> Int = core {
    bitwise-xor [SP], [SP - 1] pop
}, bitor = proc(a: Int, b: Int) -> Int = core {
    bitwise-or [SP], [SP - 1] pop
}, bitnand = proc(a: Int, b: Int) -> Int = core {
    bitwise-nand [SP], [SP - 1] pop
}, bitand = proc(a: Int, b: Int) -> Int = core {
    bitwise-and [SP], [SP - 1] pop
}, bitnot = proc(x: Int) -> Int = core {
    bitwise-not [SP]
}, inc = proc(x: &Int) -> None = core {
    inc [[SP]]
    pop
}, dec = proc(x: &Int) -> None = core {
    dec [[SP]]
    pop
}, lt = proc(a: Int, b: Int) -> Bool = core {
    lt [SP - 1], [SP], A pop
    mov A, [SP]
}, lte = proc(a: Int, b: Int) -> Bool = core {
    lte [SP - 1], [SP], A pop
    mov A, [SP]
}, gt = proc(a: Int, b: Int) -> Bool = core {
    gt [SP - 1], [SP], A pop
    mov A, [SP]
}, gte = proc(a: Int, b: Int) -> Bool = core {
    gte [SP - 1], [SP], A pop
    mov A, [SP]
}, eq = proc(a: Int, b: Int) -> Bool = core {
    eq [SP - 1], [SP], A pop
    mov A, [SP]
}, neq = proc(a: Int, b: Int) -> Bool = core {
    neq [SP - 1], [SP], A pop
    mov A, [SP]
}, putinch = proc(n: Int) -> None = core {
    put-char [SP]
    pop
} in
const alloc = proc(size: Int) -> &Int = core {
    set A, 10000
    index SP, A, C
    push C
    add [SP - 1], [[SP]]
    lea [[SP]], [SP - 1]
    add [[SP]], [SP - 1]
    pop
} in

const free = proc(ptr: &Int) -> None = {} in
proc putdec(n: Int) -> None = {
    if (lt(n, 10)) {
        putinch(n + 48)
    } else {
        putdec(n / 10);
        putinch(n % 10 + 48)
    }
} in

proc puthex(n: Int, lower: Bool) -> None = {
    if (lt(n, 16)) {
        putinch(n + if (lt(n, 10)) {
            48
        } else {
            if lower {
                87
            } else {
                55
            }
        })
    } else {
        puthex(n / 16, lower);
        puthex(n % 16, lower)
    }
} in

proc putbyte(n: Int, lower: Bool) -> None = {
    puthex(n / 16, lower);
    puthex(n % 16, lower)
} in

const putint = putdec in

const putchar = proc(ch: Char) -> None = {
    putinch(ch as Int)
} in

proc ln() -> None = {
    putchar('\n')
} in

proc min(x: Int, y: Int) -> Int = {
    if (lt(x, y)) x else y
} in
proc max(x: Int, y: Int) -> Int = {
    if (gt(x, y)) x else y
} in


type List = struct { data: Int, next: &List } in

proc sort(node: &List) -> None = {
    if (node->next as Cell as Int + 128) {
        sort(node->next);
        let a = min(node->data, node->next->data),
            b = max(node->data, node->next->data)
            in {
            if (b - node->data) {
                sort(node->next);
            };
            node->data = a;
            node->next->data = b;
        };
    }
} in

proc len(node: &List) -> Int = {
    if (node as Cell as Int + 128) {
        len(node->next) + 1
    } else {
        0
    }
} in

proc neq(a: Int, b: Int) -> Bool = {
    (if ((a - b) as Bool) 1 else 0) as Bool
} in

proc index(node: &List, n: Int) -> &List = {
    while n {
        node = node->next;
        n = n - 1;
    };
    node
} in

proc swapi(a: &Int, b: &Int) -> None = {
    let tmp = (*a) in {
        (*a) = *b;
        (*b) = tmp;
    }
} in

proc partition_arr(arr: &Int, low: Int, high: Int) -> Int = {
    let pivot = arr[high],
        i = low - 1,
        j = low in {
        while lt(j, high) {
            if (lte(arr[j], pivot)) {
                inc(&i);
                swapi(&arr[j], &arr[i]);
            };
            inc(&j);
        };
        swapi(&arr[i + 1], &arr[high]);
        i + 1
    }
} in

proc quicksort_arr(arr: &Int, low: Int, high: Int) -> None = {
    if (lt(low, high)) {
        let pi = partition_arr(arr, low, high) in {
            quicksort_arr(arr, low, pi - 1);
            quicksort_arr(arr, pi + 1, high);
        }
    }
} in

const SIZE = 100 in
let arr: &Int = alloc(SIZE * 2), i = 0, a = 5, b = 6 in {
    putchar('u');
    putchar('n');
    putchar('s');
    putchar('o');
    putchar('r');
    putchar('t');
    putchar('e');
    putchar('d');
    putchar(':');
    putchar(' ');
    putchar('[');
    while lt(i, SIZE) {
        arr[i] = SIZE - i;
        putint(arr[i]);
        if (lt(i, SIZE - 1)) {
            putchar(','); putchar(' ');
        };
        inc(&i);
    };
    putchar(']');
    quicksort_arr(arr, 0, SIZE - 1);
    putchar('\n');
    putchar('s');
    putchar('o');
    putchar('r');
    putchar('t');
    putchar('e');
    putchar('d');
    putchar(':');
    putchar(' ');
    putchar('[');
    i = 0;
    while lt(i, SIZE) {
        putint(arr[i]);
        if (lt(i, SIZE - 1)) {
            putchar(','); putchar(' ');
        };
        inc(&i);
    };
    putchar(']');
    putchar('\n');
}`);
                    break;
                case "lambda-sim":
                    source.setValue(`const putint = proc(n: Int) -> None = core {
    put-int [SP]
    pop
} in
const putchar = proc(ch: Char) -> None = core {
    put-char [SP]
    pop
} in
const lt = proc(a: Int, b: Int) -> Bool = core {
    lt [SP - 1], [SP], A pop
    mov A, [SP]
} in

type Op = struct {
    apply: proc(struct {x: Int}, Int) -> Int,
    state: struct {x: Int}
} in

proc mul(n: Int) -> Op = {
    struct {
        apply = proc(state: struct{x: Int}, y: Int) -> Int = {
            state.x * y
        },
        state = struct {x=n}
    }
} in

proc add(n: Int) -> Op = {
    struct {
        apply = proc(state: struct{x: Int}, y: Int) -> Int = {
            state.x + y
        },
        state = struct {x=n}
    }
} in

proc app(op: Op, y: Int) -> Int = {
    op.apply(op.state, y)
} in

proc putdec(n: Int) -> None = {
    if (lt(n, 10)) {
        putchar((n + 48) as Char)
    } else {
        putdec(n / 10);
        putchar((n % 10 + 48) as Char)
    }
} in

proc puthex(n: Int, lower: Bool) -> None = {
    if (lt(n, 16)) {
        putchar((n + if (lt(n, 10)) {
            48
        } else {
            if lower {
                87
            } else {
                55
            }
        }) as Char)
    } else {
        puthex(n / 16, lower);
        puthex(n % 16, lower)
    }
} in

proc putbyte(n: Int, lower: Bool) -> None = {
    puthex(n / 16, lower);
    puthex(n % 16, lower)
} in

proc ln() -> None = {
    putchar('\n')
} in

let double = mul(2),
    triple = mul(3) in {
    putdec(
        app(add(10), app(triple, app(double, 5)))
    );
    ln();

    putbyte(255, false);
}`);
                    break;
                case "pattern-matching":
                    source.setValue(`type Dir = enum { North, South, East, West } in

proc alloc(n: Int) -> &Cell = std {
    alloc [SP]
} in

proc test(i: Int) -> Char = {
    match i {
        0 => 'a',
        1 => 'b',
        2 => 'c',
        3 => 'd',
        4 => 'e',
        5 => 'f',
        6 => 'g',
        7 => 'h',
        8 => 'i',
        9 => 'j',
        _ => '?'
    }
} in

proc write(user_ptr: &Char, len: Int) -> None = {
    match user_ptr {
        Null => put "Null pointer!\\n",
        valid_ptr => {
            let i = 0 in {
                while i < len {
                    put valid_ptr[i];
                    i += 1
                }
            }
        }
    }
} in


type List = (Int, &List) in

proc putlist(l: &List) -> None = {
    match l {
        Null => put '\\n',
        valid_ptr => {
            put valid_ptr->0;
            put ' ';
            putlist(valid_ptr->1)
        }
    }
} in

let i = 0,
    pos = struct { x = 16, y = -17 },
    dir = South of Dir,
    g = (North of Dir, 2, 3, pos),
    x = match (dir, (6, 'a', pos)) {
    (North of Dir, (6, 'b', _)) => put "Wow, north 1!\\n",
    (South of Dir, (5, 'a', _)) => put "Wow, north 2!\\n",
    (North of Dir, (6, 'a', _)) => put "Wow, north 3!\\n",
    (North of Dir, (5, 'b', _)) => put "Wow, north 4!\\n",
    (North of Dir, (5, 'a', _)) => put "Wow, north 5!\\n",
    (South of Dir, (6, 'a', struct { x = 16, y = -16})) => put "Wow, north 6!\\n",
    (South of Dir, (6, 'a', struct { x = 16, y = h})) => {
        put h;
        put "Wow, north 7!\\n";
    },
    _ => put "default!\\n"
} in {
    while i < 10 {
        put test(i);
        i += 1
    };
    put "\\nDone!\\n";
    
    let str = "Hello, world!" in {
        write((&str) as &Char, 13)
    };

    if let (North of Dir, b, c, struct {x=d, y=e}) = g {
        put b;
        put c;
        put d;
        put e;
    } else {
        put "Nope!"
    };

    match (5, 8) {
        (4, x) | (x, 5) => put 'g',
        _ => put "Nope!"
    };


    type Tag = enum { A, B, C },
        Union = union {
        a: Int,
        b: Float,
        c: Bool
    } in match (C of Tag, union {a = 5, Union..}) {
        (A of Tag, u) => { put "\\na\\n"; put u },
        (B of Tag, u) => { put "\\na\\n"; put u },
        (C of Tag, u) => { put "\\na\\n"; put u },
        _ => put "Nope!"
    };
    put '\\n';


    let n = 16 in
        match (alloc(n)) {
            Null => put "Null pointer!\\n",
            valid_ptr => {
                put "Allocated ";
                put n;
                put " cells at ";
                put valid_ptr;
                put '\\n'
            }
        };


    write(Null, 10);
    
    let x = (1, Null),
        y = (2, &x),
        z = (3, &y),
        w = (4, &z) in {
        putlist(&w)
    };
}`);
                    document.getElementById("input").value = "";
                    break;
                case "cat":
                    source.setValue(`const putchar = proc(ch: Char) -> None = core {
    put-char [SP]
    pop
}, getchar = proc() -> Char = core {
    next SP
    get-char [SP]
} in let ch = getchar() in while ch {
    putchar(ch);
    ch = getchar();   
}`);
                    document.getElementById("input").value = "this is a cat program!";
                    break;
                case "factorial":
                    source.setValue(`const putint = proc(n: Int) -> None = core {
    put-int [SP]
    pop
}, getint = proc() -> Int = core {
    next SP
    get-int [SP]
} in

proc fact(n: Int) -> Int = {
    if n
        (n * fact(n - 1))
        else 1
} in putint(fact(getint()))`);
                    document.getElementById("input").value = "5";
                    break;
                case "units":
                    source.setValue(`const putint = proc(n: Int) -> None = core {
    put-int [SP]
    pop
} in
const putchar = proc(ch: Char) -> None = core {
    put-char [SP]
    pop
} in


type
    Kilometer = unit Kilometer = Int,
    Meter = unit Meter = Int,
    Second = unit Second = Int,
    MetersPerSecond = unit MetersPerSec = Meter,
    MetersPerSecondPerSecond = unit MetersPerSecondPerSecond = MetersPerSecond
in

proc shift_pos_by_dist(x0: Meter, dx: Meter) -> Meter = {
    (x0 as Int + dx as Int) as Meter
} in

proc shift_pos_with_vel(x0: Meter, v: MetersPerSecond, t: Second) -> Meter = {
    (x0 as Int + (v as Int * t as Int)) as Meter
} in

proc shift_pos_with_accel(x0: Meter, a: MetersPerSecondPerSecond, t: Second) -> Meter = {
    (x0 as Int + a as Int * t as Int * t as Int / 2) as Meter
} in

proc km_to_m(km: Kilometer) -> Meter = {
    (km as Int * 1000) as Meter
} in

proc shift_pos_with_vel_and_accel(x0: Meter, v0: MetersPerSecond, a: MetersPerSecondPerSecond, t: Second) -> Meter = {
    shift_pos_with_vel(shift_pos_with_accel(x0, a, t), v0, t)
} in

let x0: Meter = km_to_m(1 as Kilometer),
    v0: MetersPerSecond = 5 as MetersPerSecond,
    accel: MetersPerSecondPerSecond = 2 as MetersPerSecondPerSecond,
    t: Second = 10 as Second,
    in put shift_pos_with_vel_and_accel(x0, v0, accel, t)`);
                    break;
                case "collatz":
                    source.setValue(`const getint = proc() -> Int = core {
    next SP
    get-int [SP]
}, putint = proc(n: Int) -> None = core {
    put-int [SP]
    pop
}, putchar = proc(ch: Char) -> None = core {
    put-char [SP]
    pop
} in

proc step(n: Int) -> Int = {if (n % 2) (3 * n + 1) else n / 2} in
proc collatz(n: Int) -> Int = {
    let i = 0 in
        while n - 1 {
            i = i + 1;
            putint(i);
            putchar(':');
            putchar(' ');
            putint(n);
            putchar('\\n');
            n = step(n);
        };
    return n
} in collatz(getint())`);
                    document.getElementById("input").value = "129";
                    break;
                case "inline-asm":
                    source.setValue(`const putint = proc(n: Int) -> None = core {
    put-int [SP]
    pop
} in
const putchar = proc(ch: Char) -> None = core {
    put-char [SP]
    pop
} in

const asm_init = proc() -> None = core {
    fun FACT
        set A, 0
        gt [SP], A, B
        if B
            push [SP]
            dec [SP]
            call FACT
            mul [SP], [SP - 1]
            pop
        else
            set [SP], 1
        end
    end
}, fact = proc(n: Int) -> Int = core {
    call FACT
} in {
    asm_init();

    putint(fact(5)); putchar('\\n');
    putint(fact(10)); putchar('\\n');
}`);
                    break;
                case "type-demo-1":
                    source.setValue(`const putchar = proc(ch: Char) -> None = core {
    put-char [SP]
    pop
} in

const getchar = proc() -> Char = core {
    next SP
    get-char [SP]
} in

const alloc = proc(n: Int) -> &Int = std {
    alloc [SP]
} in




type List = let B = let T = Int in (T, &B) in B in

proc hmm() -> List = {
    ('~' as Int, Null)
} in

proc hmm2() -> List = {
    let ptr = alloc(sizeof(List)) as &List in {
        (*ptr) = hmm();
        (':' as Int, ptr)
    }
} in

proc hmm3() -> List = {
    let ptr = alloc(sizeof(List)) as &List in {
        (*ptr) = hmm2();
        ('!' as Int, ptr)
    }
} in

let x: let A = (Int, &A) in A
    = hmm3()
    in {
    putchar(x.1->0 as Char);
    putchar(')')
}`);
                    break;
                case "type-demo-2":
                    source.setValue(`const putint = proc(n: Int) -> None = core {
    put-int [SP]
    pop
} in

type A = Int,
    B = (Int, Int),
    C = ((Int, Int), Int),
    Test = proc(A, proc(A) -> B, proc(B) -> C) -> C
    in const
        a = 5,
        b = proc(x: Int) -> (Int, Int) = { (x, 6) },
        c = proc(x: (Int, Int)) -> ((Int, Int), Int) = { (x, 7) },
        test = proc(a: A, b: proc(A) -> B, c: proc(B) -> C) -> C = {
            c(b(a))
        }, hmm = proc(f: Test, x: Int) -> ((Int, Int), Int) = {
            f(x, b, c)
        } in {
            let result = hmm(test, a) in {
                putint((result.0).0);
                putint((result.0).1);
                putint(result.1);
            }
        }`);
                    break;
                default:
                    console.log("Unknown example: " + example);
                    break;
                }
            }
            setExampleProgram();
            document.getElementById("example").addEventListener("change", () => {
                setExampleProgram();
                document.getElementById("source").value = source.getValue();
                source.refresh();
                compile_and_run();
            });
            document.getElementById("target").addEventListener("change", () => {
                document.getElementById("source").value = source.getValue();
                source.refresh();
                compile_and_run();
            });
            document.getElementById("run").addEventListener("click", compile_and_run, false);
        </script>
        <select id="example" style="height: 3em; float: left;">
            <option value="aes">AES</option>
            <option value="quicksort">Quicksort</option>
            <option value="pattern-matching">Pattern Matching</option>
            <option value="cat">Cat</option>
            <option value="units">Units</option>
            <option value="lambda-sim">Simulate Lambda Functions</option>
            <option value="factorial">Factorial</option>
            <option value="collatz">Collatz</option>
            <option value="inline-asm">Inline Assembly Demo</option>
            <option value="type-demo-1">Type System Demo 1</option>
            <option value="type-demo-2">Type System Demo 2</option>
        </select>
        <div class="row">
            <div class="col"><textarea id="source"></textarea></div>
            <div class="col" style="height: 20em;">
                <textarea style="overflow: auto; background-color: black; color: white;" id="output"></textarea>
            </div>
        </div>
        <div>
            <textarea id="input" style="resize: none; float: left;" cols="10">Input Text</textarea>
            <select id="target" style="height: 3em; float: left;">
                <option value="run">Execution Output</option>
                <option value="asm">Assembly</option>
                <option value="vm">Virtual Machine Code</option>
                <option value="c">C Source</option>
            </select>
            <button id="run" style="height: 3em; float: left;">Compile</button>
        </div>
    </body>
</html>
<!DOCTYPE html>

<html>

<head>
    <title>hello-wasm example</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"
        integrity="sha512-8RnEqURPUc5aqFEN04aQEiPlSAdE0jlFS/9iGgUyNtwFnSKCXhmB6ZTNl7LnDtDWKabJIASzXrzD0K+LYexU9g=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css"
        integrity="sha512-uf06llspW44/LZpHzHT6qBOIVODjWtv4MxCricRxkzvopAlSWnTf6hpZTFxuuZcuNE9CBQhqE0Seu1CoRk84nQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/mode/simple.min.js"
        integrity="sha512-CGM6DWPHs250F/m90YZ9NEiEUhd9a4+u8wAzeKC6uHzZbYyt9/e2dLC5BGGB6Y0HtEdZQdSDYjDsoTyNGdMrMA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/rust/rust.min.js"
        integrity="sha512-g3Nhw36S0p4ZJQcky87D5M+vZbFvLrgsHWYltUy5IW0zKbvi8GlPRjJSo2CyUyQiU01Ier7u+rBABDs3BawKyQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/clike/clike.min.js"
        integrity="sha512-l8ZIWnQ3XHPRG3MQ8+hT1OffRSTrFwrph1j1oc1Fzc9UKVGef5XN9fdO0vm3nW0PRgQ9LJgck6ciG59m69rvfg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/ayu-dark.min.css"
        integrity="sha512-mV3RUXi1gt22jDb4UyRBFhZVFgAIiOfRE6ul+2l1Hcj6glyg6x4xlnjPH+neGm/t6XrFmsMRu4++McQu0asjqg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/ayu-mirage.min.css" integrity="sha512-83Qw5YjeKhwUh0sTjLweNX0/xqhfPAghTPNKP3W2VREm8waJe6rjrpGFN3zl9CMDoInarIjiAfNBE7p+NGPM7g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/dracula.min.css" integrity="sha512-gFMl3u9d0xt3WR8ZeW05MWm3yZ+ZfgsBVXLSOiFz2xeVrZ8Neg0+V1kkRIo9LikyA/T9HuS91kDfc2XWse0K0A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/darcula.min.css" integrity="sha512-kqCOYFDdyQF4JM8RddA6rMBi9oaLdR0aEACdB95Xl1EgaBhaXMIe8T4uxmPitfq4qRmHqo+nBU2d1l+M4zUx1g==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        .CodeMirror {
            border: 1px solid #eee;
            height: 100%;
        }
    </style>
</head>

<body style="height: 100%">
    <script type="module">
        import init, { compile_and_run } from './web.js';
        init();

        var source = CodeMirror.fromTextArea(document.getElementById("source"), {
            mode: "rust",
            lineNumbers: true,
            indentUnit: 4,
            theme: 'ayu-mirage',
            autoRefresh: true,
        });
        source.setSize("100%", "40em");
        setInterval(function () {
            document.getElementById("source").value = source.getValue();
            source.refresh()
        }, 50);
        var output = CodeMirror.fromTextArea(document.getElementById("output"), {
            mode: "text/x-csrc",
            // mode: "rust",
            lineNumbers: true,
            indentUnit: 4,
            theme: 'ayu-mirage',
            autoRefresh: true,
        });
        output.setSize("100%", "100%");
        setInterval(function () {
            if (output.getValue() != document.getElementById("output").value) {
                output.setValue(document.getElementById("output").value);
                output.refresh()
            }
        }, 50);
        function setExampleProgram() {
            // Clear all the elements in the `output-content` div
            try {
                window.eval(`
                    const parentDocument = window.parent.document;
                    var outputContent = parentDocument.getElementById("output-content");
                    if (outputContent) {
                        console.log("Clearing output-content");
                        while (outputContent.firstChild) {
                            outputContent.removeChild(outputContent.firstChild);
                        }
                    }
                `);
            } catch (e) {
                console.log("Error clearing output-content: " + e);
            }
            console.log(document.getElementById("example").value);
            switch (document.getElementById("example").value) {
                case "mandelbrot":
                    source.setValue(`fun main() {
    let (x_center, y_center) = (-0.6, 0.0);

    let width = 80;
    let height = 40;

    let max_iter = 250;
    let zoom = 1.25;

    let bounds = get_bounds(x_center, y_center, zoom);

    mandelbrot(bounds.x_min, bounds.x_max, bounds.y_min, bounds.y_max, width, height, max_iter);
}

fun mandelbrot(x_min: Float, x_max: Float, y_min: Float, y_max: Float, width: Int, height: Int, max_iter: Int) {
    let mut x0 = 0.0;
    let mut y0 = 0.0;

    let (mut x, mut y) = (0.0, 0.0);
    let mut iter = 0;
    let mut x_temp = 0.0;
    for let mut py=0; py<height; py+=1; {
        for let mut px=0; px<width; px+=1; {
            x0 = x_min + (x_max - x_min) * px / (width - 1);
            y0 = y_min + (y_max - y_min) * py / (height - 1);

            x = 0.0;
            y = 0.0;
            iter = 0;

            while x*x + y*y < 4.0 && iter < max_iter {
                x_temp = x*x - y*y + x0;
                y = 2*x*y + y0;
                x = x_temp;
                iter += 1;
            }

            if iter == max_iter {
                print(" ");
            } else if iter < max_iter / 8 {
                print(".");
            } else if iter < max_iter / 4 {
                print("*");
            } else if iter < max_iter / 2 {
                print("+");
            } else {
                print("#");
            }
        }
        print("\\n");
    }
}

fun get_bounds(x_center: Float, y_center: Float, zoom: Float): {x_min: Float, x_max: Float, y_min: Float, y_max: Float} {
    // Zoom 1.0 = (x_max - x_min) = 2.0
    let (x_min, x_max) = (x_center - 1.0 / zoom, x_center + 1.0 / zoom);
    let (y_min, y_max) = (y_center - 1.0 / zoom, y_center + 1.0 / zoom);
    return {x_min, x_max, y_min, y_max};
}

main();`);
                    break;
                case "myers-diff":
                    source.setValue(`from std.collections import *;

fun main() {
    // Example input sequences
    let a = "abcd";
    let b = "acde";
    println("First sequence:  ", a);
    println("Second sequence: ", b);
    println("Difference:");
    myers_diff(&a, sizeof(a) - 1, &b, sizeof(b) - 1);
}

enum Op {
    Insert,
    Delete,
    Match,
}

struct Edit {
    op: Op,
    // Index in sequence A
    a: Int,
    // Index in sequence B
    b: Int,
}

// Perform myers diff on two strings
fun myers_diff(a: &Char, a_len: Int, b: &Char, b_len: Int) {
    let max = a_len + b_len;
    let mut V = Vec.make<Int>();
    let mut edits = Vec.make<Edit>();

    // Initialize V array
    for let mut i=0; i<=2*max; i+=1; {
        V.push(-1);
    }

    for let mut D=0; D<=max; D+=1; {
        for let mut k=-D; k<=D; k+=2; {
            let mut x = 0;
            if k == -D or (k != D and *V.get(k-1+max) < *V.get(k+1+max)) {
                // Move down (insertion into B)
                x = *V.get(k+1+max);
            } else {
                // Move right (deletion from A)
                x = *V.get(k-1+max) + 1;
            }

            let mut y = x - k;
            // Match as far as possible along diagonal
            while x >= 0 && y >= 0 && x < a_len and y < b_len and a[x] == b[y] {
                edits.push({op=Op of Match, a=x, b=y});
                x += 1;
                y += 1;
            }

            V.set(k + max, x);

            // Avoid redundant operations by checking conditions carefully
            if x >= 0 and y >= 0 {
                if x < a_len and (y >= b_len or a[x] != b[y]) {
                    if edits.len() == 0 or (edits.get(edits.len()-1).op != (Op of Delete) or edits.get(edits.len()-1).a != x) {
                        edits.push({op=Op of Delete, a=x, b=y});
                    }
                } else if y < b_len and (x >= a_len or a[x] != b[y]) {
                    if edits.len() == 0 or (edits.get(edits.len()-1).op != (Op of Insert) or edits.get(edits.len()-1).b != y) {
                        edits.push({op=Op of Insert, a=x, b=y});
                    }
                }
            }

            // If we have reached the end of both sequences
            if x >= a_len and y >= b_len {
                let mut last_pos = 0;
                let mut last_op = Option<Op> of Nothing;
                let mut is_first = True;
                for let mut i=0; i<edits.len(); i+=1; {
                    let edit = edits.get(i);
                    if edit.a < last_pos or edit.b < last_pos {
                    } else {
                        last_pos = if edit.a > edit.b {edit.a} else {edit.b};
                        match (edit.op, last_op) {
                            // Print like a real diff
                            (of Insert, of Some(of Insert)) => {
                                print(b[edit.b]);
                            },
                            (of Insert, _) => {
                                print("\\n> ", b[edit.b]);
                            },
                            (of Delete, of Some(of Delete)) => {
                                print(a[edit.a]);
                            },
                            (of Delete, _) => {
                                print("\\n< ", a[edit.a]);
                            },
                            (of Match, of Some(of Match)) => {
                                print(a[edit.a]);
                            },
                            (of Match, _) => {
                                if not is_first {
                                    print("\\n");
                                }
                                print(a[edit.a]);
                            },
                            (_, _) => {
                                println("Error: Unknown operation");
                            }
                        }
                        is_first = False;
                        last_op = Option<Op> of Some(edit.op);
                    }
                }
                V.drop();
                edits.drop();
                return None;
            }
        }
    }
}

main();`);
                    break;
                case "const-generics":
                    source.setValue(`fun main() {
    // Create an array struct
    let mut a = Array.new<Int, 5>([1, 2, 3, 4, 5]);
    // Print it out
    a.println();
    // Set a value!
    a.set(1, 1000);
    // Print the changed value
    println(*a.get(1));
    // Print the whole changed array
    a.println();
}

// An array with a constant parameter length
struct Array<T, const N: Int> {
    data: [T * N]
}

impl Array<T, N> {
    // Create a new Array container
    fun new(arr: [T * N]): Array<T, N> {
        return {data=arr};
    }

    // Get a value from the array
    fun get(&self, n: Int): &T {
        if n < N {
            return &self.data[n];
        } else {
            return Null;
        }
    }

    // Set a value in the array
    fun set(&mut self, n: Int, val: T) {
        self.data[n] = val;
    }

    // Print the array
    fun print(&self) {
        print("[");
        for let mut i=0; i<N; i+=1; {
            print(self.data[i]);
            if i != N - 1 {
                print(", ")
            }
        }
        print("]");
    }

    fun println(&self) {
        self.print();
        println();
    }
}

main();`);
                    break;
                case "sudoku":
                    source.setValue(`fun main() {
    // Create a 9x9 sudoku board
    println("Initial board:\\n");
    let mut b = Board.new<9>([
        [5, 3, 0, 0, 7, 0, 0, 0, 0],
        [6, 0, 0, 1, 9, 5, 0, 0, 0],
        [0, 9, 8, 0, 0, 0, 0, 6, 0],
        [8, 0, 0, 0, 6, 0, 0, 0, 3],
        [4, 0, 0, 8, 0, 3, 0, 0, 1],
        [7, 0, 0, 0, 2, 0, 0, 0, 6],
        [0, 6, 0, 0, 0, 0, 2, 8, 0],
        [0, 0, 0, 4, 1, 9, 0, 0, 5],
        [0, 0, 0, 0, 8, 0, 0, 7, 9]
    ]);
    b.print();

    if b.solve() {
        println("\\nSolution:\\n");
        b.print();
        println("\\nVerified: ", b.verify());
    } else {
        println("No solution exists");
    }
}

struct Board<const N: Int> {
    data: [[Int * N] * N]
}

impl Board<N> {
    fun empty(): Board<N> {
        return {data=[[0] * N] * N};
    }

    fun new(data: [[Int * N] * N]): Board<N> {
        return {data=data};
    }

    fun is_safe(&self, row: Int, col: Int, num: Int): Bool {
        for let mut x=0; x<N; x+=1; {
            if self.data[row][x] == num {
                return False;
            }
        }

        for let mut x=0; x<N; x+=1; {
            if self.data[x][col] == num {
                return False;
            }
        }

        let mut start_row = row - row % 3;
        let mut start_col = col - col % 3;
        for let mut x=0; x< N / 3; x+=1; {
            for let mut y=0; y<N / 3; y+=1; {
                if self.data[x + start_row][y + start_col] == num {
                    return False;
                }
            }
        }

        return True;
    }

    fun find_empty_location(&self, row: &mut Int, col: &mut Int): Bool {
        for let mut i=0; i<N; i+=1; {
            for let mut j=0; j<N; j+=1; {
                if self.data[i][j] == 0 {
                    *row = i;
                    *col = j;
                    return True;
                }
            }
        }
        return False;
    }

    fun solve(&mut self): Bool {
        let mut row = 0;
        let mut col = 0;
        if !self.find_empty_location(&mut row, &mut col) {
            return True;
        }

        for let mut num=1; num<=N; num+=1; {
            if self.is_safe(row, col, num) {
                self.data[row][col] = num;
                if self.solve() {
                    return True;
                }
                self.data[row][col] = 0;
            }
        }
        return False;
    }

    fun verify(&mut self): Bool {
        for let mut i=0; i<N; i+=1; {
            for let mut j=0; j<N; j+=1; {
                let mut num = self.data[i][j];
                self.data[i][j] = 0;
                if !self.is_safe(i, j, num) {
                    return False;
                }
                self.data[i][j] = num;
            }
        }
        return True;
    }

    fun print(&self) {
        for let mut row=0; row<N; row+=1; {
            for let mut col=0; col<N; col+=1; {
                print(self.data[row][col]);
                if col % 3 == 2 && col < N - 1 {
                    print(" | ");
                } else {
                    print(" ");
                }
            }

            println("");
            if row % 3 == 2 && row < N - 1 {
                for let mut col=0; col<N; col+=1; {
                    print("--");
                    if col % 3 == 2 && col < N - 1 {
                        print("+-");
                    }
                }
                println("");
            }
        }
    }
}

main();`);
                    break;
                case "matrix":
                    source.setValue(`fun main() {
    // Create two 4x4 matrices
    let x = Matrix.new<Int, 4, 4>(10); // Populate with 10
    let y = Matrix.new<Int, 4, 4>(5);  // Populate with 5

    // Print the two matrices
    x.print();
    y.print();

    // Provide the matrix with the operations for the elem type
    fun add_ints(a: Int, b: Int): Int = a + b;
    fun mul_ints(a: Int, b: Int): Int = a * b;

    // Perform the mat mul!
    let z = y.mul<4>(&x, 0, add_ints, mul_ints);
    // Print the result
    z.print();
}

// Define a constant sized matrix with a generic element type
// and parameterized width and height.
struct Matrix<T, const Rows: Int, const Cols: Int> {
    arr: [[T * Cols] * Rows]
}

// Add some methods to our matrix
impl Matrix<T, Rows, Cols> {
    // Create a new matrix populated with initial values
    fun new(x: T): Matrix<T, Rows, Cols> {
        return {arr=[[x] * Cols] * Rows};
    }

    // Get a value from a matrix
    fun get(&self, row: Int, col: Int): &T {
        return &self.arr[row][col];
    }

    // Multiply with another matrix
    fun mul<const NewCols: Int>(
        &self,
        other: &Matrix<T, Cols, NewCols>,
        zero: T,
        add: fun(T, T) -> T,
        mul: fun(T, T) -> T
    ): Matrix<T, Rows, NewCols> {
        let mut result = Matrix.new<T, Rows, NewCols>(zero);
        for let mut j=0; j<NewCols; j+=1; {
            for let mut i=0; i<Rows; i+=1; {
                let mut sum = zero;
                for let mut k=0; k<Cols; k+=1; {
                    sum = add(sum, mul(self.arr[i][k], other.arr[k][j]));
                }
                result.arr[i][j] = sum;
            }
        }
        result
    }

    // Print the matrix
    fun print(&self) {
        for let mut row=0; row<Rows; row+=1; {
            for let mut col=0; col<Cols; col+=1; {
                print(*self.get(row, col), " ");
            }
            println();
        }
        println();
    }
}

main();`);
                    break;
                case "hashmap":
                    source.setValue(`from std.collections import *;

fun main() {
    let mut hm = HashMap.make<Point, Int>();
    // Add some data associated with the points into the map
    hm.insert(Point.new(4.0, 5.0), 5);
    hm.insert(Point.new(1.0, -1.0), -100);
    // Print the map
    hm.println();
    // Retrieve the data associated with a point
    let idx = Point.new(1.0, -1.0);
    if let of Some(result) = hm.get(idx) {
        println(idx, " -> ", *result);
    } else {
        println("Could not find hm[", idx, "]");
    }
}

struct Point { x: Float, y: Float }

impl Point {
    fun new(x: Float, y: Float): Point {
        return {x=x, y=y};
    }

    fun move(&mut self, dx: Float, dy: Float) {
        self.x += dx;
        self.y += dy;
    }
}

main();`);
                    break;
                case "aes":
                    source.setValue(`fun print_hex(n: Int, lower: Bool) {
    if n < 10 {
        print((n + '0' as Int) as Char);
    } else if n < 16 {
        print((n - 10 + (if lower { 'a' } else { 'A' }) as Int) as Char);
    } else {
        print_hex(n / 16, lower);
        print_hex(n % 16, lower);
    }
}

fun print_byte(mut n: Int, lower: Bool) {
    n &= 0xFF;
    print_hex(n / 16, lower);
    print_hex(n % 16, lower);
}

fun left_shift(mut a: Int, mut b: Int): Int {
    while b {
        a *= 2;
        b -= 1;
    }
    return a;
}

const MIN_INT = -2147483648;

fun right_shift(mut a: Int, mut b: Int): Int {
    let mut offset = MIN_INT;
    let was_negative = a < 0;
    for let mut i=0; i < b - 1; i += 1; {
        offset /= 2;
    }

    if was_negative { a = ~a; }
    
    while b {
        a /= 2;
        b -= 1;
    }

    if was_negative { a = ~a ^ offset; }

    return a;
}

fun print_hexln(n: Int, lower: Bool) {
    print_hex(n, lower);
    print("\\n");
}

fun print_byteln(n: Int, lower: Bool) {
    print_byte(n, lower);
    print("\\n");
}

fun xtime(mut n: Int): Int {
    n &= 0xFF;
    n *= 2;

    if n < 0x100 {
        n
    } else {
        n ^ 0x1B
    }
}

fun multiply(mut a: Int, mut b: Int): Int {
    a &= 0xFF;
    b &= 0xFF;
    let mut result = 0;
    let mut next_term = a;
    for let mut i=0; i < 8; i += 1; {
        if b & 1 {
            result ^= next_term;
        }
        next_term = xtime(next_term);
        b /= 2;
    }

    return result & 0xFF;
}

type State = [Int * 16];

fun row_major(c0r0: Int, c1r0: Int, c2r0: Int, c3r0: Int,
    c0r1: Int, c1r1: Int, c2r1: Int, c3r1: Int,
    c0r2: Int, c1r2: Int, c2r2: Int, c3r2: Int,
    c0r3: Int, c1r3: Int, c2r3: Int, c3r3: Int): State {
    return [
        c0r0, c0r1, c0r2, c0r3,
        c1r0, c1r1, c1r2, c1r3,
        c2r0, c2r1, c2r2, c2r3,
        c3r0, c3r1, c3r2, c3r3
    ];
}

fun col_major(c0r0: Int, c0r1: Int, c0r2: Int, c0r3: Int,
    c1r0: Int, c1r1: Int, c1r2: Int, c1r3: Int,
    c2r0: Int, c2r1: Int, c2r2: Int, c2r3: Int,
    c3r0: Int, c3r1: Int, c3r2: Int, c3r3: Int): State {
    return [
        c0r0, c0r1, c0r2, c0r3,
        c1r0, c1r1, c1r2, c1r3,
        c2r0, c2r1, c2r2, c2r3,
        c3r0, c3r1, c3r2, c3r3
    ];
}

fun get(state: &State, row: Int, col: Int): Int {
    return (state as &Int)[row * 4 + col];
}

fun set(state: &mut State, row: Int, col: Int, value: Int) {
    (state as &mut Int)[row * 4 + col] = value;
}

fun print_state(self: &State) {
    for let mut i=0; i < 4; i += 1; {
        for let mut j=0; j < 4; j += 1; {
            print_byte(get(self, i, j), False);
            print(" ");
        }
        print("\\n");
    }
}

fun rotate_row(self: &mut State, row: Int, steps: Int) {
    for let mut i=0; i<steps; i += 1; {
        let temp = get(self, row, 0);
        set(self, row, 0, get(self, row, 1));
        set(self, row, 1, get(self, row, 2));
        set(self, row, 2, get(self, row, 3));
        set(self, row, 3, temp);
    }
}

fun shift_rows(self: &mut State) {
    rotate_row(self, 1, 1);
    rotate_row(self, 2, 2);
    rotate_row(self, 3, 3);
}

fun inverse_shift_rows(self: &mut State) {
    rotate_row(self, 1, 3);
    rotate_row(self, 2, 2);
    rotate_row(self, 3, 1);
}

fun add_round_key(self: &mut State, round_key: &State) {
    let round_key_ptr = round_key as &Int;
    let self_ptr = self as &mut Int;
    for let mut i=0; i < 16; i += 1; {
        self_ptr[i] ^= round_key_ptr[i];
    }
}

fun mix_columns(self: &mut State) {
    for let mut j=0; j < 4; j += 1; {
        let s0 = get(self, 0, j);
        let s1 = get(self, 1, j);
        let s2 = get(self, 2, j);
        let s3 = get(self, 3, j);

        set(self, 0, j, multiply(0x02, s0) ^ multiply(0x03, s1) ^ s2 ^ s3);
        set(self, 1, j, s0 ^ multiply(0x02, s1) ^ multiply(0x03, s2) ^ s3);
        set(self, 2, j, s0 ^ s1 ^ multiply(0x02, s2) ^ multiply(0x03, s3));
        set(self, 3, j, multiply(0x03, s0) ^ s1 ^ s2 ^ multiply(0x02, s3));
    }
}

fun inverse_mix_columns(self: &mut State) {
    for let mut j=0; j < 4; j += 1; {
        let s0 = get(self, 0, j);
        let s1 = get(self, 1, j);
        let s2 = get(self, 2, j);
        let s3 = get(self, 3, j);

        set(self, 0, j, multiply(0x0e, s0) ^ multiply(0x0b, s1) ^ multiply(0x0d, s2) ^ multiply(0x09, s3));
        set(self, 1, j, multiply(0x09, s0) ^ multiply(0x0e, s1) ^ multiply(0x0b, s2) ^ multiply(0x0d, s3));
        set(self, 2, j, multiply(0x0d, s0) ^ multiply(0x09, s1) ^ multiply(0x0e, s2) ^ multiply(0x0b, s3));
        set(self, 3, j, multiply(0x0b, s0) ^ multiply(0x0d, s1) ^ multiply(0x09, s2) ^ multiply(0x0e, s3));
    }
}


fun substitute_byte(mut byte: Int): Int {
    let S_BOX = [[99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118], [202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192], [183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21], [4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117], [9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132], [83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207], [208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168], [81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210], [205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115], [96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219], [224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121], [231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8], [186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138], [112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158], [225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223], [140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]];
    byte &= 0xFF;
    let row = right_shift(byte, 4) & 0xF;
    let col = byte & 0xF;
    return S_BOX[row][col];
}

fun inverse_substitute_byte(mut byte: Int): Int {
    let INVERSE_S_BOX = [[82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251], [124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203], [84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78], [8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37], [114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146], [108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132], [144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6], [208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107], [58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115], [150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110], [71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27], [252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244], [31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95], [96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239], [160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97], [23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]];
    byte &= 0xFF;
    let row = right_shift(byte, 4) & 0xF;
    let col = byte & 0xF;
    return INVERSE_S_BOX[row][col];
}

fun substitute_bytes(self: &mut State) {
    for let mut i=0; i < 4; i += 1; {
        for let mut j=0; j < 4; j += 1; {
            set(self, i, j, substitute_byte(get(self, i, j)));
        }
    }
}

fun inverse_substitute_bytes(self: &mut State) {
    for let mut i=0; i < 4; i += 1; {
        for let mut j=0; j < 4; j += 1; {
            set(self, i, j, inverse_substitute_byte(get(self, i, j)));
        }
    }
}

enum Key {
    Key128([Int * 16]),
    Key192([Int * 24]),
    Key256([Int * 32]),
}

fun get_key_rounds(self: &Key): Int {
    match self {
        &of Key128(_) => 10,
        &of Key192(_) => 12,
        &of Key256(_) => 14,
        _ => 0
    }
}

fun get_key_length(self: &Key): Int {
    match self {
        &of Key128(_) => 4,
        &of Key192(_) => 6,
        &of Key256(_) => 8,
        _ => 0
    }
}

fun get_key_size(self: &Key): Int {
    return get_key_length(self) * 4;
}

fun get_key_data(key: &Key): &Int = key as &Int;

fun print_key(self: &Key) {
    match self {
        &of Key128(key) => print("Key128: "),
        &of Key192(key) => print("Key192: "),
        &of Key256(key) => print("Key256: "),
        _ => print("Unknown key type: ")
    }
    let size = get_key_size(self);
    let data = get_key_data(self);
    for let mut i=0; i < size; i+=1; {
        print_byte(data[i], False);
    }
}

fun print_keyln(self: &Key) {
    print_key(self);
    print("\\n");
}


fun substitute_word(word: Int): Int {
    let byte0 = substitute_byte(right_shift(word, 24) & 0xFF);
    let byte1 = substitute_byte(right_shift(word, 16) & 0xFF);
    let byte2 = substitute_byte(right_shift(word, 8) & 0xFF);
    let byte3 = substitute_byte(word & 0xFF);
    return left_shift(byte0, 24) + left_shift(byte1, 16) + left_shift(byte2, 8) + byte3;
}

fun rotate_word(word: Int): Int {
    let byte0 = right_shift(word, 24) & 0xFF;
    let byte1 = right_shift(word, 16) & 0xFF;
    let byte2 = right_shift(word, 8) & 0xFF;
    let byte3 = word & 0xFF;
    return left_shift(byte1, 24) + left_shift(byte2, 16) + left_shift(byte3, 8) + byte0;
}

fun word(byte3: Int, byte2: Int, byte1: Int, byte0: Int): Int {
    return left_shift(byte3, 24) + left_shift(byte2, 16) + left_shift(byte1, 8) + byte0;
}

fun bytes(word: Int): [Int * 4] {
    let byte0 = right_shift(word, 24) & 0xFF;
    let byte1 = right_shift(word, 16) & 0xFF;
    let byte2 = right_shift(word, 8) & 0xFF;
    let byte3 = word & 0xFF;
    return [byte0, byte1, byte2, byte3];
}

fun round_key(word0: Int, word1: Int, word2: Int, word3: Int): State {
    let bytes0 = bytes(word0);
    let bytes1 = bytes(word1);
    let bytes2 = bytes(word2);
    let bytes3 = bytes(word3);
    return col_major(bytes0[0], bytes1[0], bytes2[0], bytes3[0],
              bytes0[1], bytes1[1], bytes2[1], bytes3[1],
              bytes0[2], bytes1[2], bytes2[2], bytes3[2],
              bytes0[3], bytes1[3], bytes2[3], bytes3[3]);
}

fun key_expansion(key: &Key, nr: Int, nk: Int): &Int {
    let key_data = key as &Int;
    let w = alloc(4 * (nr + 1) * sizeof<Int>()) as &mut Int;
    for let mut i=0; i < nk; i+=1; {
        w[i] = word(key_data[4*i], key_data[4*i+1], key_data[4*i+2], key_data[4*i+3]);
    }

    let rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    for let mut i=nk; i < 4 * (nr + 1); i += 1; {
        let mut temp = w[i-1];
        if i % nk == 0 {
            temp = substitute_word(rotate_word(temp)) ^ word(rcon[i / nk - 1], 0, 0, 0);
        } else if nk == 8 && i % nk == 4 {
            temp = substitute_word(temp);
        }

        w[i] = w[i-nk] ^ temp;
    }

    return w;
}

fun cipher(self: &mut State, key: &Key) {
    let len = get_key_length(key);
    let nr = get_key_rounds(key);
    let k = key_expansion(key, nr, len);
    let mut rk = round_key(k[0], k[1], k[2], k[3]);
    add_round_key(self, &rk);
    for let mut i=4; i < 4 * (nr + 1); i+=4; {
        rk = round_key(k[i], k[i+1], k[i+2], k[i+3]);
        substitute_bytes(self);
        shift_rows(self);
        if i < 4 * nr {
            mix_columns(self);
        }
        add_round_key(self, &rk);
    }

    free(k);
}

fun inverse_cipher(self: &mut State, key: &Key) {
    let len = get_key_length(key);
    let nr = get_key_rounds(key);
    let k = key_expansion(key, nr, len);

    let mut rk = round_key(k[4*nr], k[4*nr+1], k[4*nr+2], k[4*nr+3]);
    add_round_key(self, &rk);
    for let mut i=4*nr-4; i >= 0; i-=4; {
        rk = round_key(k[i], k[i+1], k[i+2], k[i+3]);
        inverse_shift_rows(self);
        inverse_substitute_bytes(self);
        add_round_key(self, &rk);
        if i > 0 {
            inverse_mix_columns(self);
        }
    }

    free(k);
}
let key = Key of Key128 [
    0x00, 0x01, 0x02, 0x03,
    0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F
];


let mut state: State = row_major(
    0x00, 0x01, 0x02, 0x03,
    0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F
);

print_keyln(&key);
print("Raw\\n");
print_state(&state);
print("\\n");
print("Cipher\\n");
cipher(&mut state, &key);
print_state(&state);
print("\\n");
print("Inverse-Cipher\\n");
inverse_cipher(&mut state, &key);
print_state(&state);
print("\\n");`);
                    break;
                case "structural-types":
                    source.setValue(`fun main() {
    // Add the position and the size to get a rectangle
    let rect = Position.make(10, 20) + Size.make(30, 40);

    // Print the rectangle and its stats
    println("Rectangle: ", rect);
    println("Area:      ", rect.area()); 
    println("Perimeter: ", rect.perimeter());
}

// A rectangle has an \`x\` and \`y\` position, a \`width\`, and a \`height\`.
struct Rectangle {
    x: Int,
    y: Int,
    width: Int,
    height: Int
}

impl Rectangle {
    // Calculate the area of the rectangle
    fun area(&self): Int { self.width * self.height }

    // Calculate the perimeter of the rectangle
    fun perimeter(&self): Int { 2 * (self.width + self.height) }
}

// A type for representing the dimensions of a 2D shape
struct Size {
    width: Int,
    height: Int
}

impl Size {
    // Create a new size with the given width and height
    fun make(width: Int, height: Int): Size { { width=width, height=height } }
}

// A type for representing the position of a 2D shape
struct Position {
    x: Int,
    y: Int
}

impl Position {
    // Create a new position with the given x and y coordinates
    fun make(x: Int, y: Int): Position { { x=x, y=y } }
}

main();`);
                    break;
                case "result":
                    source.setValue(`from std.fallible import Result;


// An error type that represents a failure in the program
enum Error {
    // A division by zero error
    DivideByZero {
        // The numerator of the division
        numerator: Int,
    },
    // An invalid input error
    InvalidInput,
}

// The main function of the program is fallible, so it returns a Result
fun main(): Result<(), Error> {
    // Divide 5 by 1
    match divide(5, 1) {
        of Ok(n) => println("Success (this is expected)! ", n, " is a valid result."),
        of Err(e) => println("Caught error (unexpected): ", e)
    }
    println();

    // Divide 2 by 0
    match divide(2, 0) {
        of Ok(n) => println("Success (unexpected): ", n, " is a valid result."),
        of Err(e) => println("Caught error (this is expected)! ", e)
    }
    println();

    return Result<(), Error> of Ok(());
}

// Divide two integers, returning a fallible result
fun divide(x: Int, y: Int): Result<Int, Error> {
    println("About to divide ", x, " and ", y);
    if y == 0 {
        return Result<Int, Error> of Err(Error of DivideByZero { numerator = x });
    } else {
        return Result<Int, Error> of Ok(x / y);
    }
}

if let of Err(e) = main() {
    println("Error: ", e);
}`);
                    break;
                case "list":
                    source.setValue(`from std.fallible import Option;
from std.collections import *;

fun main() {
    from std.math import gcd;
    println("GCD of 12 and 15 is ", gcd(12, 15));

    print("List of integers:  ");
    let vals = range(0, 10);
    vals.println();
    
    // Create a new list of all the squares of the values in the first list
    fun square(n: Int): Int = n * n;
    let squares = vals.map<Int>(square);
    
    // Print the squared values
    print("List of squares:  ");
    squares.println();
}

// Create a list of integers from a low to a high value
fun range(low: Int, high: Int): List<Int> {
    // Create a linked list of integers
    let mut vals = List<Int> of Nil;
    
    // Add some values to the list
    for let mut i=high; i>=low; i-=1; {
        vals = vals.cons(i);
    }

    vals
}
main();`);
                    break;
                case "vector":
                    source.setValue(`from std.collections import *;

fun main() {
    // Create a vector of integers
    let mut v = Vec.make<Int>();

    // Print the length
    println("v.len() = ", v.len());
    
    // Add 100 elements
    for let mut i=0; i<100; i+=1; { v.push(i); }
    // Print the new length
    println("v.len() = ", v.len());

    fun double(x: Int): Int = x * 2;
    fun sum(x: Int, y: Int): Int = x + y;

    // Create a new vector with all the values doubled
    let mut v2 = v.map<Int>(double);
    println("v2.len() = ", v2.len());

    // Print the sum of all the elements in the original vector
    println("sum of v = ", v.reduce<Int>(sum, 0));
    // Print the sum of all the elements in the new, doubled vector
    println("sum of v2 = ", v2.reduce<Int>(sum, 0));

    // Print all the elements in the new, doubled vector
    for let mut i=0; i<v2.len(); i+=1; {
        println("v2[", i, "] = ", *v2.get(i));
    }
}

main();`);
                    break;

                case "calculator":
                    document.getElementById("input").value = "(4 + 6) * ((8 - 3) / 2) + (9 % 5)";
                    source.setValue(`enum Expr {
    Add (&Expr, &Expr),
    Sub (&Expr, &Expr),
    Mul (&Expr, &Expr),
    Div (&Expr, &Expr),
    Rem (&Expr, &Expr),
    Num Float,
    Group &Expr,
}

struct Input {
    start: &Char,
    loc: Int,
    length: Int
}

enum ParseResult {
    Ok (Input, &Expr),
    Err Int
}

fun is_ok(result: ParseResult): Bool {
    match result {
        of Ok _ => True,
        of Err _ => False
    }
}

fun putint(n: Int) {
    if (n < 0) {
        print('-');
        putint(-n);
    } else if (n < 10) {
        print(('0' as Int + n) as Char);
    } else {
        putint(n / 10);
        print(('0' as Int + n % 10) as Char);
    }
}

fun main() {
    let mut is_done = False;
    print("+ Adam's Calculator\\n");
    print("  Welcome to Adam's calculator!\\n");
    print("+ About\\n");
    print("  This is written in the Sage programming language: https:\\/\\/adam-mcdaniel.net\\/sage\\n");
    print("  And compiled as an ELF userspace application for our custom OS!\\n");
    print("+ Usage\\n");
    print("  This calculator supports the following infix operators: \\\"+\\\", \\\"-\\\", \\\"*\\\", \\\"/\\\", \\\"%\\\"\\n");
    print("  Type a math expression (integers only) to evaluate it.\\n");
    print("  Type \\\"exit\\\" to quit the program.\\n");
    print("  Example expression syntax: (4 + 6) * ((8 - 2) / 2) + (9 % 5)\\n");
    let buf = alloc(sizeof<Char>() * 1024) as &mut Char;

    let exit_text = "exit\\0";
    let exit_str = (&exit_text) as &Char;
    while !is_done {
        let input = read(buf);

        match parse_expr(input) {
            of Ok (input, n) => {
                print("Input: ");
                print_expr(n);
                print("\\n => ");
                print(eval(n));
                print("\\n");
                free_expr(n);
            },
            of Err n => {
                if (is_ok(parse_symbol(input, exit_str))) {
                    is_done = True;
                } else if (input.length > 0) {
                    print("\\nCalculator: error while parsing at character: \\n", input.start[n], "\\n");
                } else {
                    print("No input\\n");
                }
            }
        }
    }
    print("Bye!\\n");
}


fun eval(expr: &Expr): Float = match *expr {
    of Add (lhs, rhs) => eval(lhs) + eval(rhs),
    of Sub (lhs, rhs) => eval(lhs) - eval(rhs),
    of Mul (lhs, rhs) => eval(lhs) * eval(rhs),
    of Div (lhs, rhs) => eval(lhs) / eval(rhs),
    of Rem (lhs, rhs) => eval(lhs) % eval(rhs),
    of Num n => n,
    of Group inner => eval(inner)
};

fun print_expr(expr: &Expr) {
    match *expr {
        of Add(lhs, rhs) => {
            print_expr(lhs);
            print(" + ");
            print_expr(rhs);
        },
        of Sub(lhs, rhs) => {
            print_expr(lhs);
            print(" - ");
            print_expr(rhs);
        },
        of Mul(lhs, rhs) => {
            print_expr(lhs);
            print(" * ");
            print_expr(rhs);
        },
        of Div(lhs, rhs) => {
            print_expr(lhs);
            print(" / ");
            print_expr(rhs);
        },
        of Rem(lhs, rhs) => {
            print_expr(lhs);
            print(" % ");
            print_expr(rhs);
        },
        of Num n => print(n),
        of Group expr => {
            print("(");
            print_expr(expr);
            print(")");
        }
    }
}

fun free_expr(expr: &Expr) {
    match *expr {
        of Add (lhs, rhs)
        | of Sub (lhs, rhs)
        | of Mul (lhs, rhs)
        | of Div (lhs, rhs)
        | of Rem (lhs, rhs) => {
            free_expr(lhs);
            free_expr(rhs);
        },
        of Group inner => free_expr(inner),
        _ => {}
    }
    free(expr);
}

fun free_input(input: Input) {
    free(input.start);
}

fun is_between_inclusive(ch: Char, start: Char, end: Char): Bool {
    let start = start as Int;
    let end = end as Int;
    let ch = ch as Int;

    return start <= ch && ch <= end;
}

fun parse_float(mut input: Input): ParseResult {
    let save = input;
    let mut n = 0.0;

    if (input.loc == input.length) {
        return ParseResult of Err (input.loc);
    }

    if !(is_between_inclusive(input.start[input.loc], '0', '9')) {
        return ParseResult of Err (input.loc);
    }

    for (); input.loc < input.length && is_between_inclusive(input.start[input.loc], '0', '9'); input.loc += 1; {
        n *= 10;
        n += (input.start[input.loc] as Int - '0' as Int) as Int;
    }

    if (input.loc < input.length && input.start[input.loc] == '.') {
        input.loc += 1;
        let mut m = 0.1;
        for (); input.loc < input.length && is_between_inclusive(input.start[input.loc], '0', '9'); input.loc += 1; {
            n += (input.start[input.loc] as Int - '0' as Int) as Int * m;
            m *= 0.1;
        }
    }
    return ParseResult of Ok (input, new Expr of Num n);
}

fun binop(
    lhs: &Expr,
    mut input: Input,
    op: Char,
    factor: fun(Input) -> ParseResult,
    cons: fun(&Expr, &Expr) -> &Expr): ParseResult {

    input = parse_whitespaces(input);
    if (input.loc == input.length) {
        return ParseResult of Err (input.loc);
    }

    if input.start[input.loc] == op {
        input.loc += 1;
        input = parse_whitespaces(input);
        match factor(input) {
            of Ok (input, rhs) => {
                return ParseResult of Ok (input, cons(lhs, rhs));
            },
            of Err _ => {
                return ParseResult of Err (input.loc);
            }
        }
    } else {
        return ParseResult of Err (input.loc);
    }
}

fun parse_expr(mut input: Input): ParseResult {
    let save = input;

    if (input.loc == input.length) {
        return ParseResult of Err (input.loc);
    }

    fun add_cons(lhs: &Expr, rhs: &Expr): &Expr {
        return new Expr of Add(lhs, rhs);
    } 
    fun sub_cons(lhs: &Expr, rhs: &Expr): &Expr {
        return new Expr of Sub(lhs, rhs);
    }

    match parse_term(input) {
        of Ok (new_input, mut lhs) => {
            input = new_input;
            while True {
                lhs = match binop(lhs, input, '+', parse_term, add_cons) {
                    of Ok (new_input, new_lhs) => {
                        input = new_input;
                        new_lhs;
                    },
                    of Err _ => match binop(lhs, input, '-', parse_term, sub_cons) {
                        of Ok (new_input, new_lhs) => {
                            input = new_input;
                            new_lhs;
                        },
                        of Err _ => {
                            return ParseResult of Ok (input, lhs);
                        }
                    }
                };
            }
            return ParseResult of Ok (input, lhs);
        },
        of Err _ => {return ParseResult of Err (input.loc);}
    }
}

fun parse_term(mut input: Input): ParseResult {
    let save = input;

    if (input.loc == input.length) {
        return ParseResult of Err (input.loc);
    }

    fun mul_cons(lhs: &Expr, rhs: &Expr): &Expr {
        return new Expr of Mul(lhs, rhs);
    } 
    fun div_cons(lhs: &Expr, rhs: &Expr): &Expr {
        return new Expr of Div(lhs, rhs);
    }
    fun rem_cons(lhs: &Expr, rhs: &Expr): &Expr {
        return new Expr of Rem(lhs, rhs);
    }

    match parse_atom(input) {
        of Ok (new_input, mut lhs) => {
            input = new_input;
            while True {
                lhs = match binop(lhs, input, '*', parse_atom, mul_cons) {
                    of Ok (new_input, new_lhs) => {
                        input = new_input;
                        new_lhs;
                    },
                    of Err _ => match binop(lhs, input, '/', parse_atom, div_cons) {
                        of Ok (new_input, new_lhs) => {
                            input = new_input;
                            new_lhs;
                        },
                        of Err _ => match binop(lhs, input, '%', parse_atom, rem_cons) {
                            of Ok (new_input, new_lhs) => {
                                input = new_input;
                                new_lhs;
                            },
                            of Err _ => {
                                return ParseResult of Ok (input, lhs);
                            }
                        }
                    }
                };
            }
            return ParseResult of Ok (input, lhs);
        },
        of Err _ => {return ParseResult of Err (input.loc);}
    }
}

fun parse_symbol(mut input: Input, match_string: &Char): ParseResult {
    let save = input;

    if (input.loc == input.length) {
        return ParseResult of Err (input.loc);
    }

    for let mut i = 0; match_string[i] != '\\0'; i+=1; {
        if (input.loc == input.length || input.start[input.loc] != match_string[i]) {
            return ParseResult of Err (input.loc);
        }
        input.loc += 1;
    }

    return ParseResult of Ok (input, new Expr of Num 0.0);
}

fun parse_atom(input: Input): ParseResult {
    let save = input;

    if (input.loc == input.length) {
        return ParseResult of Err (input.loc);
    }

    let result = parse_float(input);
    if let of Err _ = result {
        return parse_group(input);
    }
    return result;
}

fun parse_group(mut input: Input): ParseResult {
    let save = input;

    if (input.loc == input.length) {
        return ParseResult of Err (input.loc);
    }

    if (input.start[input.loc] != '(') {
        return ParseResult of Err (input.loc);
    }

    input.loc += 1;
    let input = parse_whitespaces(input);

    return match parse_expr(input) {
        of Ok (mut input, expr) => {
            input = parse_whitespaces(input);
            if (input.start[input.loc] != ')') {
                return ParseResult of Err (input.loc);
            }
            input.loc += 1;
            ParseResult of Ok (input, new Expr of Group(expr));
        },
        of Err _ => ParseResult of Err (input.loc)
    };
}

fun parse_whitespaces(mut input: Input): Input {
    let save = input;

    if (input.loc == input.length) {
        return input;
    }

    for (); input.loc < input.length && (input.start[input.loc] == ' ' || input.start[input.loc] == '\r' || input.start[input.loc] == '\\n'); input.loc += 1; {}

    return input;
}

fun is_done(input: Input): Bool = input.loc >= input.length;

fun strlen(ch: &Char): Int {
    let mut i = 0;
    for (); ch[i] != '\\0'; i+=1; {}
    return i;
}

fun is_ascii(ch: Char): Bool {
    return ch as Int < 128;
}

fun getchar(): Char {
    let mut ch = '\\0';

    while !(is_ascii(ch)) || ch == '\\0' {
        input(&mut ch);
    }

    return ch;
}

fun readline(ch: &mut Char, len: Int): Int {
    let mut i = len;

    let mut c = getchar();
    
    for (); c != '\\n' && c != '\\0'; i+=1; {
        ch[i] = c;
        c = getchar();
    }
    return i;
}

fun read(buf: &mut Char): Input {
    print(">>> ");
    let len = readline(buf, 0);
    buf[len] = '\\0';

    return {
        start = buf as &Char,
        length = strlen(buf),
        loc = 0
    };
}
fun test(): Input {
    let buf = alloc(sizeof<Char>() * 1024) as &mut Char;
    let text = "(4 + 6) * ((8 - 3) / 2) + (9 % 5)";
    for let mut i = 0; text[i] != '\\0'; i+=1; {
        buf[i] = text[i];
    }
    
    return {
        start = buf as &Char,
        length = strlen(buf),
        loc = 0
    };
}


fun test_main() {
    let input = test();

    match parse_expr(input) {
        of Ok (input, n) => {
            print_expr(n);
            print("\\n => ");
            print(eval(n));
            print("\\n");
            free_expr(n);
        },
        of Err n => {
            print("\\nCalculator: error while parsing at character: \\n", input.start[n], "\\n");
        }
    }
}

test_main();`);
                    break;
                case "match":
                    source.setValue(`// Create a C-like enum
enum Direction {
    North, South, East, West
}

// Pattern match over a tuple of a Direction, Int, and struct
match (Direction of South, 2, {x = 5, y = -6}) {
    (of North, _, _)
    | (of East, _, _)
    | (of West, _, _)
    | (of South, 3, _) => print("Incorrect!\\n"),
    (of South, 2, {x = 5, y = -6}) => {
        // This will be the branch that matches
        print("Correct!\\n");
    },
    _ => print("Incorrect!\\n")
}

// Create a polymorphic Rust-like enum
enum Option<T> {
    Some(T),
    Nothing
}

// Define a fallible division operation
fun divide(n: Int, d: Int): Option<Int> {
    if (d == 0) {
        return Option<Int> of Nothing;
    } else {
        return Option<Int> of Some(n / d);
    }
}

// Match over a division operation with an if-let statement
if let of Some(n) = divide(6, 2) {
    print("6 / 2 = ", n, "\\n");
} else {
    print("6 / 2 = undefined\\n");
}`);
                    document.getElementById("input").value = "";
                    break;
                case "cat":
                    source.setValue(`let mut ch = ' ';
input(&mut ch);
while (ch != '\\0') {
    print(ch);
    input(&mut ch);
}`);
                    document.getElementById("input").value = "this is a cat program!";
                    break;
                case "tuple":
                    source.setValue(`// Define a type for a pair of tuple elements
type Pair<A, B> = (A, B);

impl Pair<A, B> {
    // Get the first tuple element
    fun first(&self): A { self.0 }
    // Get the second tuple element
    fun second(&self): B { self.1 }
}

// Make a pair of elements
let tup = ("hello", "world!");

// Print the two elements separated by a space
println(tup.first(), " ", tup.second());

// Make a pair of an Int and a Float
let tup2 = (5, 6.5);
println(tup2.first() + tup2.second());`);
                    break;
                case "factorial":
                    source.setValue(`fun fact(n: Int): Int {
    match n {
        0 | 1 => 1,
        _ => n * fact(n - 1)
    }
}

let mut n = 0;
input(&mut n);

print(fact(n));`);
                    document.getElementById("input").value = "5";
                    break;
                case "ffi":
                    source.setValue(`// NOTE: I have *explicitly* given the VM access to the JavaScript functions 
// \`alert\` and \`eval\` internally. If you try and call any other
// foreign function, the VM will not have bindings for them and will halt.
// Running someone else's code in a safe manner is as simple as making
// sure you only provide bindings for safe foreign functions to execute!
// (e.g.\`eval\` is surely not safe, but something like \`alert\` is generally safe.)

extern fun alert(message: &Char);
extern fun eval(code: &mut Char, size: Int);

const BUFFER_SIZE = 1024;

fun read(buf: &mut Char) {
    let mut ch = ' ';
    input(&mut ch);
    for let mut i = 0; ch; i+=1; {
        buf[i] = ch;
        input(&mut ch);
    }
}

fun write(buf: &Char) {
    for let mut i = 0; buf[i]; i+=1; {
        print(buf[i]);
    }
}

let buf = alloc(BUFFER_SIZE) as &mut Char;

// Read the code to evaluate from the input box!
read(buf);
print("Input code: ");
write(buf);

// Evaluate the code in the input box!
eval(buf, BUFFER_SIZE);

// Print the result of the evaluation to the output box!
print("\\nResult: ");
write(buf);

// Call the JavaScript alert function!
alert(buf);`);
                    document.getElementById("input").value = "('b' + 'a' + + 'a' + 'a').toUpperCase()";
                    break;

                case "graphics":
                    source.setValue(`// This is a simple graphics demo that uses the JavaScript FFI to draw
// random squares, circles, plus some Sin waves on a Canvas. It uses the
// \`eval\` function to execute the JavaScript code that draws the shapes
// on the canvas.

// NOTE: I have *explicitly* given the VM access to the JavaScript functions 
// \`alert\` and \`eval\` internally. If you try and call any other
// foreign function, the VM will not have bindings for them and will halt.
// Running someone else's code in a safe manner is as simple as making
// sure you only provide bindings for safe foreign functions to execute!
// (e.g.\`eval\` is surely not safe, but something like \`alert\` is generally safe.)
// Eval is all you need!
extern fun eval(str: &mut Char, size: Int);

const RECTANGLE_COUNT = 50;
const CIRCLE_COUNT = 50;
const RECTANGLE_WIDTH = 20;
const RECTANGLE_HEIGHT = 20;

fun main() {
    println("Hello, world!");
    
    // Make a 400x400 canvas
    let mut canvas = Canvas.make(400, 400);
    // Clear the canvas to black
    canvas.clear(Color.BLACK);

    // Draw some random rectangles with some random colors
    let width = 20;
    let height = 20;
    for let mut i = 0; i < RECTANGLE_COUNT; i += 1; {
        // Get a random rectangle on the canvas
        let rect = canvas.rand_section(RECTANGLE_WIDTH, RECTANGLE_HEIGHT);
        // Fill the rectangle with a random color
        canvas.draw_rect(Color.rand(), rect);
        // Fill inside the rectangle with a different color
        canvas.draw_rect(Color.rand(), rect.shrink(4));
    }

    // Draw some random circles with some random colors
    let radius = 15;
    for let mut i = 0; i < CIRCLE_COUNT; i += 1; {
        let (x, y) = (rand(0, canvas.width), rand(0, canvas.height));
        canvas.draw_circle(Color.rand(), x, y, radius);
    }

    // Draw some wavy lines
    // Define some colors to use for the lines
    let colors = Color.PRIMARY + Color.SECONDARY;
    // Get the number of colors
    let len = sizeof(colors) / sizeof<Color>();

    // Draw the lines over the canvas
    for let mut i = 0; i < canvas.width; i += 3; {
        let rect = Rectangle.make(i, ((i / 60.0).sin() * 100.0 + 120.0) as Int, 6, 6);
        for let mut j = 0; j < len; j += 1; {
            canvas.draw_rect(colors[j], rect.move(0, (j * 30.0) as Int));
        }
    }
}

impl Float {
    fun abs(self): Float {
        if self < 0.0 {
            return -self;
        }
        return self;
    }

    fun square(self): Float {
        return self * self;
    }

    fun cube(self): Float {
        return self * self * self;
    }

    fun sin(mut self): Float {
        // Taylor series approximation
        self %= 3.14159 * 2;
        let mut result = 0.0;
        let mut term = self;
        let mut i = 1;
        while i < 10 {
            result += term;
            term *= -self * self / (2 * i + 1) / (2 * i);
            i += 1;
        }
        return result;
    }

    fun cos(mut self): Float {
        // Taylor series approximation
        self %= 3.14159 * 2;
        let mut result = 0.0;
        let mut term = 1.0;
        let mut i = 0;
        while i < 10 {
            result += term;
            term *= -self * self / (2 * i + 2) / (2 * i + 1);
            i += 1;
        }
        return result;
    }
}

struct Canvas {
    width: Int,
    height: Int,
}

impl Canvas {
    fun clear(&mut self, color: Color) {
        // Draw the background
        let rect = Rectangle.make(0, 0, self.width, self.height);
        self.draw_rect(color, rect);
    }

    fun rand_section(&self, width: Int, height: Int): Rectangle {
        return {
            x=rand(0, self.width - width),
            y=rand(0, self.height - height),
            width=width,
            height=height
        };
    }

    fun make(width: Int, height: Int): Canvas {
        let mut buf = \"try {window.eval(\`
        const parentDocument = window.parent.document;
        let output = parentDocument.getElementById('output-content');
        var context = null;
        var added_elements = [];
        var canvas = null;
        canvas = document.createElement('canvas');\" + ['\\0'] * 1000;
        
        let width_str = width.to_str();
        let height_str = height.to_str();
        
        strcat(&mut buf, &\"canvas.width = \");
        strcat(&mut buf, &width_str);
        strcat(&mut buf, &\"; canvas.height = \");
        strcat(&mut buf, &height_str);
        
        strcat(&mut buf, &\"; var parentElement = output;
        if (!parentElement) {
            console.error('Parent element not found.', output);
        }
        parentElement.appendChild(canvas);
        var spacer = document.createElement('br');
        parentElement.appendChild(spacer);
        context = canvas.getContext('2d');
        function draw_rect(color, x, y, width, height) {
          context.fillStyle = color;
          context.fillRect(x, y, width, height);
        }
        function draw_circle(color, x, y, radius) {
          context.fillStyle = color;
          context.beginPath();
          context.arc(x, y, radius, 0, 2 * Math.PI);
          context.fill();
        }
        \`);} catch { alert(\\\"Could not create canvas on parent web-page from the embedded compiler: Disable the \\\\\\\"same-origin\\\\\\\" policy to fix this! (only affects this example)\\\"); }\");
        
        eval(&mut buf, 2048);
        return {
            width=width,
            height=height
        };
    }

    fun draw_rect(&mut self, color: Color, rect: Rectangle) {
        let mut command_str = ['\\0'] * 128;
        let color_str = color.to_str();
        let rect_str = rect.to_str();
        strcat(&mut command_str, &"draw_rect(\\"#");

        strcat(&mut command_str, &color_str);
        strcat(&mut command_str, &"\\", ");

        strcat(&mut command_str, &rect_str);
        strcat(&mut command_str, &");");
        // println("about to eval: ", command_str);
        eval(&mut command_str, sizeof(command_str));
    }

    fun draw_circle(&mut self, color: Color, x: Int, y: Int, radius: Int) {
        let mut command_str = ['\\0'] * 128;
        let color_str = color.to_str();
        let x_str = x.to_str();
        let y_str = y.to_str();
        let radius_str = radius.to_str();
        strcat(&mut command_str, &"draw_circle(\\\"#");

        strcat(&mut command_str, &color_str);
        strcat(&mut command_str, &"\\", ");

        strcat(&mut command_str, &x_str);
        strcat(&mut command_str, &", ");

        strcat(&mut command_str, &y_str);
        strcat(&mut command_str, &", ");

        strcat(&mut command_str, &radius_str);
        strcat(&mut command_str, &");");
        eval(&mut command_str, sizeof(command_str));
    }
}

let static mut SEED: Int = 0x12345;

fun seed(n: Int) {
    SEED = n;
}

fun rand(low: Int, high: Int): Int {
    SEED = (SEED * 1103515245 + 12345) & 0x7FFFFFFF;
    return low + SEED % (high - low);
}

impl Int {
    fun to_str(&self): [Char * 9] {
        let mut n = *self;
        let mut result = [' '] * 9;
        result[8] = '\\0';
        for let mut i=0; i<8; i+=1; {
            let digit = n % 10;
            result[7 - i] = (digit + '0' as Int) as Char;
            n /= 10;
        }

        // Remove trailing zeros
        let mut i = 0;
        let mut is_done = False;
        while i < 8 && !is_done {
            if result[i] != '0' {
                is_done = True;
                i -= 1;
            }
            i += 1;
        }

        for let mut j=0; j<i; j+=1; {
            result[j] = ' ';
        }

        // If the result is empty, then just return "0"
        for let mut j=0; j<8; j+=1; {
            if result[j] != ' ' {
                return result;
            }
        }
        result[7] = '0';
        return result;
    }
}

struct Color {
    r: Int,
    g: Int,
    b: Int,
}

impl Color {
    const RED = {r=255, g=0, b=0};
    const GREEN = {r=0, g=255, b=0};
    const BLUE = {r=0, g=0, b=255};
    const BLACK = {r=0, g=0, b=0};
    const WHITE = {r=255, g=255, b=255};
    const YELLOW = {r=255, g=255, b=0};
    const CYAN = {r=0, g=255, b=255};
    const MAGENTA = {r=255, g=0, b=255};

    const PRIMARY = [
        Color.RED,
        Color.GREEN,
        Color.BLUE,
    ];

    const SECONDARY = [
        Color.YELLOW,
        Color.CYAN,
        Color.MAGENTA,
    ];

    fun rand(): Color {
        return {
            r=rand(0, 256),
            g=rand(0, 256),
            b=rand(0, 256)
        };
    }

    fun make(r: Int, g: Int, b: Int): Color {
        return {
            r=r,
            g=g,
            b=b
        };
    }

    fun to_str(&self): [Char * 7] {
        let mut result = [' '] * 7;
        result[6] = '\\0' as Char;
        let mut hex = byte_to_hex(self.r);
        result[0] = hex[0];
        result[1] = hex[1];

        hex = byte_to_hex(self.g);
        result[2] = hex[0];
        result[3] = hex[1];

        hex = byte_to_hex(self.b);
        result[4] = hex[0];
        result[5] = hex[1];

        return result;
    }
}

struct Rectangle {
    x: Int,
    y: Int,
    width: Int,
    height: Int,
}

impl Rectangle {
    fun make(x: Int, y: Int, width: Int, height: Int): Rectangle {
        return {
            x=x,
            y=y,
            width=width,
            height=height
        };
    }

    fun rand_section(&self, width: Int, height: Int): Rectangle {
        let mut x = rand(self.x, self.x + self.width - width);
        let mut y = rand(self.y, self.y + self.height - height);
        return {
            x=x,
            y=y,
            width=width,
            height=height
        };
    }

    // Remove margin
    fun shrink(&self, margin: Int): Rectangle {
        return {
            x=self.x + margin,
            y=self.y + margin,
            width=self.width - margin * 2,
            height=self.height - margin * 2
        };
    }

    fun move(&self, dx: Int, dy: Int): Rectangle {
        return {
            x=self.x + dx,
            y=self.y + dy,
            width=self.width,
            height=self.height
        };
    }

    fun to_str(&self): [Char * 40] {
        let mut result = [' '] * 40;
        let x_str = self.x.to_str();
        // println("x_str: ", x_str);
        let y_str = self.y.to_str();
        // println("y_str: ", y_str);
        let width_str = self.width.to_str();
        // println("width_str: ", width_str);
        let height_str = self.height.to_str();
        // println("height_str: ", height_str);
        let mut i = 0;

        for (); i < 8; i += 1; {
            result[i] = x_str[i];
        }

        result[8] = ',' as Char;
        i += 1;

        for (); i < 16; i += 1; {
            result[i] = y_str[i - 8];
        }
        result[16] = ',' as Char;
        i += 1;

        for (); i < 24; i += 1; {
            result[i] = width_str[i - 16];
        }
        result[24] = ',' as Char;
        i += 1;

        for (); i < 32; i += 1; {
            result[i] = height_str[i - 24];
        }

        result[32] = '\\0' as Char;
        i += 1;


        return result;
    }
}

fun strcat(dst: &mut Char, src: &Char) {
    let mut i = 0;
    while dst[i] != '\\0' {
        i += 1;
    }

    let mut j = 0;
    while src[j] != '\\0' {
        dst[i] = src[j];
        i += 1;
        j += 1;
    }
    dst[i] = '\\0';
}


fun byte_to_hex(mut byte: Int): [Char * 3] {
    // Convert a byte to a hex string
    let mut result = ['0'] * 3;

    let mut i = 0;
    while i < 2 {
        let mut digit = byte & 0xF;
        if digit < 10 {
            digit += '0' as Int;
        } else {
            digit += 'A' as Int - 10;
        }
        result[i] = digit as Char;
        byte /= 16;
        i += 1;
    }
    result[2] = '\\0' as Char;

    return result;
}

fun byte_to_dec(mut byte: Int): [Char * 4] {
    // Convert a byte to a decimal string
    let mut result = [' '] * 4;

    let mut i = 0;
    while i < 3 {
        let mut digit = byte % 10;
        digit += '0' as Int;
        result[i] = digit as Char;
        byte /= 10;
        i += 1;
    }
    result[3] = '\\0' as Char;

    return result;
}

main();`);
                    break;

                case "hello world":
                    source.setValue(`// Welcome to the Sage programming language!

// Click the \`Compile\` button below to execute the program!
// Use the \`example\` dropdown above to see some example programs!
// Use the \`target\` dropdown below to see the different stages of compilation.

// You can write Sage code without a \`main\` function like Python!
println("Hello, world!");`);
                    document.getElementById("input").value = "";
                    break;

                case "let-bindings":
                    source.setValue(`// Let bindings are used to bind a name to a value.
let text = "Hello, world!";
println(text);

// Variables are immutable by default -- use \`mut\` to make them mutable.
let mut num = 5;
num += 1;
println("5 + 1 = ", num);

// Let bindings can also bind to patterns.
let (mut a, b, {x, y, z}) = (999.999, 2, {x=3, y=4, z=5});
a = 1.0;
println("a: ", a);
println("b: ", b);
println("x: ", x);
println("y: ", y);
println("z: ", z);`)
                    break;
                case "modules":
                    document.getElementById("input").value = "hello modules!";
                    source.setValue(`// Define a module \`io\` with \`getchar\`
mod io {
    fun getchar(): Char {
        let mut ch = '\\0';
        input(&mut ch);
        return ch;
    }
}

// A module to test importing from other modules
mod testing {
    mod internals {
        // Import getchar from two modules up
        from io import getchar;
        
        // Use it in a function
		fun get_two(): (Char, Char) { (getchar(), getchar()) }
    }

    // Get two chars and print them
    fun get_two_then_print() {
        // Import from a submodule, which imports from a supermodule
        from internals import get_two;
        let (a, b) = get_two();
        print(a, b);
    }
}

from testing import get_two_then_print;
get_two_then_print();

// Get two values and print them
for let mut i=0; i<6; i+=1; {
    // We can also use the full path name
 	testing.get_two_then_print();
}`);
                    break;
                case "sum-types":
                    source.setValue(`fun main() {
    let x = Option<Int> of Some(5);
    println(x.unwrap());
}

enum Option<T> {
    Some(T),
    Nothing,
}

fun panic(): Never {
    println("Panicking!");
    while True {}
}

impl Option<T> {
    fun unwrap(self): T {
        println("Unwrapping option!");
        match self {
            of Some(x) => x,
            of Nothing => panic()
        }
    }
}

main();`)
                    break;
                default:
                    console.log("Unknown example: " + example);
                    break;
            }
        }
        setExampleProgram();
        document.getElementById("example").addEventListener("change", () => {
            setExampleProgram();
            document.getElementById("source").value = source.getValue();
            source.refresh();
            compile_and_run();
        });
        document.getElementById("target").addEventListener("change", () => {
            document.getElementById("source").value = source.getValue();
            source.refresh();
            // Clear all the elements in the `output-content` div
            try {
                window.eval(`
                    const parentDocument = window.parent.document;
                    var outputContent = parentDocument.getElementById("output-content");
                    if (outputContent) {
                        console.log("Clearing output-content");
                        while (outputContent.firstChild) {
                            outputContent.removeChild(outputContent.firstChild);
                        }
                    }
                `);
            } catch (e) {
                console.log("Error clearing output-content: " + e);
            }
            compile_and_run();
        });
        document.getElementById("run").addEventListener("click", () => {
            // Clear all the elements in the `output-content` div
            try {
                window.eval(`
                    const parentDocument = window.parent.document;
                    var outputContent = parentDocument.getElementById("output-content");
                    if (outputContent) {
                        console.log("Clearing output-content");
                        while (outputContent.firstChild) {
                            outputContent.removeChild(outputContent.firstChild);
                        }
                    }
                `);
            } catch (e) {
                console.log("Error clearing output-content: " + e);
            }

            compile_and_run();
        }, false);
        </script>

        <select id="example" style="height: 3em; float: left;">
            <option value="hello world">Click to select example program (Default Hello World)</option>
            <option value="graphics">Screen-Drawing Javascript Interop</option>
            <option value="sudoku">Sudoku Solver</option>
            <option value="list">Standard Lib Linked List</option>
            <option value="result">Standard Lib Error Handling</option>
            <option value="hashmap">Standard Lib Hashmap</option>
            <option value="vector">Standard Lib Vector</option>
            <option value="structural-types">Structural Typing Demo</option>
            <option value="ffi">Alert Javascript Demo</option>
            <option value="matrix">Matrix Operations</option>
            <option value="mandelbrot">Mandelbrot Set</option>
            <option value="modules">Module System</option>
            <option value="const-generics">Const-Generics</option>
            <option value="sum-types">Sum Types</option>
            <option value="match">Pattern Matching</option>
            <option value="tuple">Pair (Generics)</option>
            <option value="factorial">Factorial</option>
            <option value="let-bindings">Let-Bindings</option>
            <option value="calculator">Calculator (Parser)</option>
            <option value="aes">AES (128, 192, 256 bit (en/de)crypt)</option>
            <option value="myers-diff">Myers Difference Algorithm</option>
            <option value="cat">Cat</option>
        </select>
        <div class="row">
            <div class="col"><textarea id="source"></textarea></div>
            <div class="col" style="height: 20em;">
                <textarea style="overflow: auto; background-color: black; color: white;" id="output"></textarea>
            </div>
        </div>
        <div id="input-div">
            <textarea id="input" style="resize: none; float: left;" cols="10">Input Text</textarea>
            <select id="target" style="height: 3em; float: left;">
                <option value="run"><b>Click to see stages of output</b></option>
                <option value="run">Execution Output</option>
                <option value="lir">Lower IR</option>
                <option value="asm">Assembly IR</option>
                <option value="vm">Virtual Machine Code</option>
                <option value="c">C Source</option>
                <!-- <option value="x86">x86 Assembly</option> -->
            </select>
            <button id="run" style="height: 3em; float: left;">Compile</button>
        </div>
        <script>
            compile_and_run();
        </script>
    </body>
</html>
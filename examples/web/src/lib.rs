use wasm_bindgen::JsCast;
mod device;
mod interpreter;
mod utils;
use device::WasmDevice;
use interpreter::WasmInterpreter;
use sage::{
    lir::*,
    parse::*,
    targets::{self, CompiledTarget},
    vm::*,
    *,
};
use std::fmt;
use wasm_bindgen::prelude::*;

/// A function to reinterpret the bits of an integer as a float.
pub fn as_float(n: i64) -> f32 {
    f32::from_bits(n as u32)
}

/// A function to reinterpret the bits of a float as an integer.
pub fn as_int(n: f32) -> i64 {
    n.to_bits() as i64
}

// Called by our JS entry point to run the example
#[wasm_bindgen(start)]
pub fn main_js() -> Result<(), JsValue> {
    utils::set_panic_hook();
    compile_and_run()
}

#[wasm_bindgen]
extern "C" {
    // Use `js_namespace` here to bind `console.log(..)` instead of just
    // `log(..)`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // The `console.log` is quite polymorphic, so we can bind it with multiple
    // signatures. Note that we need to use `js_name` to ensure we always call
    // `log` in JS.
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    // Multiple arguments too!
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &str, b: &str);

    fn alert(s: &str);

    fn eval(s: &str) -> JsValue;
}

macro_rules! console_log {
    // Note that this is using the `log` function imported above during
    // `bare_bones`
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

/// The types of errors returned by the CLI.
enum BetterError {
    /// With the given source code location and the source code itself.
    WithSourceCode {
        loc: SourceCodeLocation,
        source_code: String,
        err: Box<Self>,
    },
    /// Error in reading source or writing generated code.
    IO(std::io::Error),
    /// Error parsing the source code.
    Parse(String),
    /// Error generated when compiling LIR code.
    LirError(lir::Error),
    /// Error generated when assembling input code.
    AsmError(asm::Error),
    /// Error generated by the interpreter executing input code.
    InterpreterError(String),
    /// Error when building the virtual machine code for a given target.
    BuildError(String),
    /// Invalid source code (expected core but got standard).
    InvalidSource(String),
}

impl BetterError {
    pub fn annotate_with_source(self, code: &String) -> Self {
        match self {
            Self::LirError(lir::Error::Annotated(err, Annotation::Location(loc))) => {
                Self::WithSourceCode {
                    loc: loc.clone(),
                    source_code: code.clone(),
                    err: Box::new(BetterError::LirError(*err)),
                }
            }
            _ => self,
        }
    }
}

impl fmt::Debug for BetterError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::IO(e) => write!(f, "IO error: {:?}", e),
            Self::Parse(e) => write!(f, "Parse error: {}", e),
            Self::AsmError(e) => write!(f, "Assembly error: {:?}", e),
            Self::LirError(e) => write!(f, "LIR error: {}", e),
            Self::WithSourceCode {
                loc,
                source_code,
                err,
            } => {
                // use codespan_reporting::files::SimpleFiles;
                use codespan_reporting::diagnostic::{Diagnostic, Label};
                use codespan_reporting::files::SimpleFiles;
                use codespan_reporting::term::{
                    emit,
                    termcolor::{ColorChoice, NoColor, StandardStream},
                };
                use no_comment::{languages, IntoWithoutComments};

                let SourceCodeLocation {
                    line,
                    column,
                    filename,
                    offset,
                    length,
                } = loc;

                let mut files = SimpleFiles::new();

                let source_code = source_code
                    .to_string()
                    .chars()
                    .without_comments(languages::rust())
                    .collect::<String>();

                let filename = filename.clone().unwrap_or("unknown".to_string());

                let file_id = files.add(filename.clone(), source_code);
                let loc = format!("{}:{}:{}:{}", filename, line, column, offset);
                // let code = format!("{}\n{}^", code, " ".repeat(*column - 1));
                // write!(f, "Error at {}:\n{}\n{:?}", loc, code, err)?
                let diagnostic = Diagnostic::error()
                    .with_message(format!("Error at {}", loc))
                    .with_labels(vec![Label::primary(
                        file_id,
                        *offset..*offset + length.unwrap_or(0),
                    )
                    .with_message(format!("{err:?}"))]);
                let mut error: Vec<u8> = vec![];
                let mut writer = NoColor::new(&mut error);
                let config = codespan_reporting::term::Config::default();
                emit(&mut writer, &config, &files, &diagnostic).unwrap();

                let error = String::from_utf8(error).unwrap();
                write!(f, "{}", error)?;
                Ok(())
            }
            Self::InterpreterError(e) => write!(f, "Interpreter error: {}", e),
            Self::BuildError(e) => write!(f, "Build error: {}", e),
            Self::InvalidSource(e) => write!(f, "Invalid source: {}", e),
        }
    }
}
#[wasm_bindgen(js_name = compile_and_run)]
pub fn compile_and_run() -> Result<(), JsValue> {
    // Use `web_sys`'s global `window` function to get a handle on the global
    // window object.
    let window = web_sys::window().expect("no global `window` exists");
    let document = window.document().expect("should have a document on window");

    let source_code = document
        .get_element_by_id("source")
        .unwrap()
        .dyn_into::<web_sys::HtmlTextAreaElement>()
        .unwrap()
        .value();
    let input = document
        .get_element_by_id("input")
        .unwrap()
        .dyn_into::<web_sys::HtmlTextAreaElement>()
        .unwrap()
        .value();
    console_log!("input `{input:?}` + code `{source_code:?}`");
    // Manufacture the element we're gonna append
    let output = document
        .get_element_by_id("output")
        .unwrap()
        .dyn_into::<web_sys::HtmlTextAreaElement>()
        .unwrap();
    output.set_value("");
    let device = WasmDevice::new(input);
    console_log!("input device `{device:?}`...");

    let target = document
        .get_element_by_id("target")
        .unwrap()
        .dyn_into::<web_sys::HtmlSelectElement>()
        .unwrap()
        .value();
    let contents = match sage::parse::parse_frontend(source_code.clone(), Some("text-box")) {
        Ok(lir_code) => {
            match lir_code
                .clone()
                .compile()
                .map_err(BetterError::LirError)
                .map_err(|e| e.annotate_with_source(&source_code))
            {
                Ok(asm_code) => {
                    console_log!("successfully compiled to asm {asm_code:?}");
                    match target.as_str() {
                        "run" => {
                            let device = WasmInterpreter::new(device)
                                .run(
                                    &match asm_code {
                                        Ok(core) => core.into(),
                                        Err(std) => std,
                                    }
                                    .assemble(8192)
                                    .unwrap(),
                                )
                                .unwrap();
                            String::from_utf8(device.output.into_iter().map(|n| n as u8).collect())
                                .unwrap()
                        }
                        "lir" => lir_code.to_string(),
                        "asm" => {
                            match asm_code {
                                // If we got back a valid program, assemble it and return the result.
                                Ok(asm_code) => asm_code.to_string(),
                                Err(asm_code) => asm_code.to_string(),
                            }
                        }
                        "vm" => {
                            match asm_code {
                                // If we got back a valid program, assemble it and return the result.
                                Ok(asm_code) => asm_code.assemble(8192).unwrap().to_string(),
                                Err(asm_code) => asm_code.assemble(8192).unwrap().to_string(),
                            }
                        }
                        "c" => {
                            match asm_code {
                                // If we got back a valid program, assemble it and return the result.
                                Ok(asm_code) => targets::C::default()
                                    .build_core(&asm_code.assemble(8192).unwrap())
                                    .unwrap(),
                                Err(asm_code) => targets::C::default()
                                    .build_std(&asm_code.assemble(8192).unwrap())
                                    .unwrap(),
                            }
                        }
                        "x86" => {
                            match asm_code {
                                // If we got back a valid program, assemble it and return the result.
                                Ok(asm_code) => targets::X86::default()
                                    .build_core(&asm_code.assemble(8192).unwrap())
                                    .unwrap(),
                                Err(asm_code) => targets::X86::default()
                                    .build_std(&asm_code.assemble(8192).unwrap())
                                    .unwrap(),
                            }
                        }
                        otherwise => {
                            console_log!("unknown target `{otherwise:?}`");
                            unreachable!()
                            // panic!("Unknown target `{otherwise:?}`");
                        }
                    }
                }
                Err(e) => {
                    console_log!("error compiling to asm {e:?}");
                    format!("{e:?}")
                }
            }
        }
        Err(e) => {
            console_log!("error parsing {e:?}");
            e.to_string()
        }
    };

    console_log!("output `{contents:?}`");
    output.set_value(&contents);

    Ok(())
}
